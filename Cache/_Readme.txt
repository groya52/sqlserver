Объекты имеющие собвственные планы выполнения:
    Stored Procedures
    Scalar-valued Functions
    Milti-statement Table-valued Function
    Triggers
    
Вложенные хранимые процедуры/динамический SQL имеют собственые планы выполнения.
Планы выполнения динамических запросов, помещаются в кэш, точно так же как и планы для хранимых процедур.

План удаляется из кэша, когда:
    - Буфер кэша SQL Server полностью использован (SQL Server должен удалить из кэша некоторые устаревшие данные)
    - ALTER PROCEDURE
    - sp_recompile
    - DBCC FREEPROCCACHE (целиком очищает кэш планов)
    - Перезапуск SQL Server
    - Изменение определенных параметров конфигурации (при помощи sp_configure или Server Properties в среде SSMS)

События, которые не вызывают вытеснение из кэша плана хранимой процедуры, но вызывают перекомпиляцию одной или более инструкций в процедуре 
(планы для двух инструкций в процедуре могут быть скомпилированы для разных значений «прослушанных» параметров (не косается локальных параметров (есть одно исключение, это табличные переменные, SQL Server оценивает табличные переменные как таблицы, возвращающие одну строку, но когда происходит перекомпиляция, оценка может отличаться)):
    - Изменение структуры таблицы или представления, участвующей в инструкции.
    - Удаление или добавление индекса для таблицы, участвующей в инструкции (это включает в себя и перестроение индекса).
    - Новая или обновленная статистика для таблицы, участвующей в инструкции.

Для обычных таблиц пороги обновления статистики следующие:
    - Когда таблица пуста, статистика устаревает, когда вы добавляете в таблицу данные.
    - Когда таблица имеет менее 500 строк, статистика устаревает после каждых 500 изменений в столбцах статистики.
    - Когда таблица имеет 500 или более строк, статистика устаревает после каждых 500 и более изменений 
      (или 20 процентов от общего количества строк в таблице) в столбцах статистики, 
      в случаях, когда уровень совместимости базы данных составляет менее 130 (SQL Server 2016). 
      Для баз данных с уровнем совместимости 130 или когда флаг трассировки T2371 включен, 
      этот порог является динамическим и основан на общем количестве строк в таблице.

Подсказка KEEPFIXED PLAN принуждает оптимизатор запросов не перекомпилировать запрос при изменении статистики.
Запрос будет перекомпилирован только при изменении схемы базовых таблиц или sp_recompile выполняется для этих таблиц.

Вы можете избежать перекомпиляции, вызванной временной таблицей, если вы используете табличные переменные. 
Поскольку для табличных переменных не создаются статистические данные, различные проблемы перекомпиляции, 
связанные с временными таблицами, к нему не применимы.
      
Причина раздвоения планов в кеше:
    - Разные опции SET ON/OFF. Планы, созданные с помощью одного набора опций SET ON/OFF не могут быть повторно использованы сеансами, 
      использующими другой набор опций SET ON/OFF.
    - Другой распространенной причиной дублирования планов в кеше является использование неквалифицированных имен объектов без указания схемы объекта. 
      В этом случае SQL Server решает объекты на основе схемы по умолчанию пользователей базы данных.

SQL Server не кэширует планы, если пакет или объект содержат строковые литералы размером более 8 КБ.

SQL Server просматривает значение параметров во время оптимизации (прослушивание параметров), 
генерирует и кэширует план, который является оптимальным для этих значений. 
Оптимизатор не имеет представления о значениях переменных времени выполнения. 
Однако, он знает, какие значения указал пользователь для параметров процедуры.
Когда данные распределяются неравномерно, это может привести к ситуации, 
когда сгенерированный и кэшированный план оптимален только для нетипичных, редко используемых значений параметров.
Если план был удален из кеша или произошли события, которые вызывают перекомпиляцию одной или более инструкций в процедуре, 
новый сгенерированный и кэшированный план может быть построн для нетипичных, редко используемых значений параметров.

Кэшированные планы должны быть действительны для каждой возможной комбинации параметров.

Способы решения проблемы: 
    - Принудительная перекомпиляция хранимой процедуры с помощью EXECUTE WITH RECOMPILE 
      или использование WITH RECOMPILE в качестве части определения процедуры (вводит накладные расходы на постоянные перекомпиляции).
    - Принудительная перекомпиляция инструкций с предложением OPTION (RECOMPILE) (вводит накладные расходы на постоянные перекомпиляции,
      перекомпиляция на уровне инструкций предпочтительнее, потому что она выполняет перекомпиляцию в меньшей области).
    - Использовать подсказку OPTIMIZE FOR, которая заставляет SQL Server оптимизировать запрос для определенных значений параметров, 
      указанных в подсказке (это может привести к проблемам, когда распределение данных изменилось).
    - OPTIMIZE FOR UNKNOWN с этой подсказкой SQL Server выполняет оптимизацию на основе наиболее статистически общего значения в таблице 
      (можно добиться тех же результатов, используя локальные переменные вместо параметров).

SQL Server не будет генерировать и кэшировать план, который использует отфильтрованный индекс в случаях, 
когда этот индекс не может использоваться с некоторой комбинацией значений параметров.

Отключить параметр sniffing, traceflag 4136.
    
SQL Server 2016 позволяет управлять прослушиванием параметров на уровне базы данных с помощью команды 
ALTER DATABASE SCOPED CONFIGURATION SET PARAMETER_SNIFFING или на уровне запросов используя подсказку DISABLE_PARAMETER_SNIFFING.
Отключение прослушивания параметров эквивалентно использованию подсказки OPTIMIZE FOR UNKNOWN со всеми запросами. 
 
Отличие DISABLE_PARAMETER_SNIFFING от OPTIMIZE FOR UNKNOWN в том, что при помощи OPTIMIZE FOR UNKNOWN можно указать конкретный параметр, 
который нужно оптимизировать так, как если бы его значение было неизвестным, DISABLE_PARAMETER_SNIFFING отключит прослушивание всех параметров.

Команда, ALTER DATABASE SCOPED CONFIGURATION CLEAR PROCEDURE_CACHE, 
позволяет очистить кэш плана процедуры для базы данных.
        
Хранимая процедура sp_executesql позволяет явно параметризовать переменные части запроса, 
и поэтому он может обеспечить повторное использование плана выполнения так же эффективно, как хранимая процедура.
Запрос, для которого создается план, должен соответствовать точной текстовой строке параметризованного запроса, представленного через sp_executesql.
Поэтому, если один и тот же запрос отправляется из разных частей приложения, убедитесь, что одна и та же текстовая строка используется во всех местах.
        
SQL Server кэширует планы для ad-hoc запросов/пакетов, 
которые используют константы, а не параметры в предложении WHERE. 
SQL Server повторно использует планы для ad-hoc запросов только в тех случаях, 
когда запросы точно совпадают (учитывая регистр символов).

SQL Server может неявно параметризовать запрос, 
чтобы увеличить возможность повторного использования плана используя функцию, 
называемую простой параметризацией.

Простая параметризация происходит только тогда, 
когда кэшированный план считается безопасным для параметризации, 
а это означает, что план будет одинаковым с точки зрения формы плана и оценки мощности, 
даже когда значения константы/параметра изменились. 

Например, план с поиском по уникальному индексу безопасен, потому что он никогда не вернет больше одной строки, 
независимо от значения параметра.
Более того, существует множество языковых конструкций, которые препятствуют простой параметризации, 
такие как IN, TOP, DISTINCT, JOIN, UNION, подзапросы и многие другие.

Когда включен параметр конфигурации сервера под названием Optimize for ad-hoc workloads (по умолчанию отключен, рекомендуется данный параметр конфигурации держать включенным), 
SQL Server кэширует небольшие структуры размером менее 300 байтов, называемые скомпилированными заглушками плана, 
а не фактическими скомпилированными планами (это может значительно снизить использование памяти кэш-памяти плана в системах с тяжелой случайной активностью).
Когда один и тот же запрос выполняется во второй раз, SQL Server заменяет скомпилированный план заглушки фактическим скомпилированным планом.

SQL Server может использовать принудительную параметризацию, которая может быть включена на уровне базы данных с помощью команды 
ALTER DATABASE SET PARAMETERIZATION FORCED или на уровне запроса с подсказкой PARAMETERIZATION FORCED.

Принудительная параметризация имеет ряд преимуществ и недостатков. 
С одной стороны, она может значительно уменьшить размер кеша плана и загрузку процессора, 
а также увеличивает вероятность не оптимальных планов выполнения из-за проблем с параметризацией.
Это особенно важно для фильтрованных индексов, где параметризация может помешать SQL Server генерировать и кэшировать план, 
который использует их, заменяя постоянные значения в операторах параметрами.

Это дает вам представление о типах ограничений, применяемых к принудительной параметризации. 
Принудительная параметризация действительно будет полезной, только если вы страдаете от большого количества компиляций и перекомпилируете из-за специальных запросов. 
Любая другая нагрузка не будет пользоваться преимуществами принудительной параметризации.

Прежде чем вы начнете использовать принудительную параметризацию, ознакомтесь с ограничениями https://technet.microsoft.com/ru-ru/library/ms175037(v=sql.105).aspx.

Руководство плана, позволяют добавлять подсказки к запросам или даже принудительно выполнять конкретные планы выполнения без изменения текста запроса. 
Руководства по плану поддерживаются только в выпусках Standard, Enterprise и Developer SQL Server.
Вы можете создать их с помощью хранимой процедуры sp_create_plan_guide и управлять ими с помощью хранимой процедуры sp_control_plan_guide.

Типы руководств плана:
    - В руководстве по планированию объектов вы можете указать подсказку для запроса, 
      который существует в объекте T-SQL, например, хранимая процедура, триггер или пользовательская функция.
    - В руководстве по планированию вы можете указать подсказку для конкретного SQL-запроса, как автономного, так и частичного пакета.
    - В руководстве по планированию вы можете указать тип параметризация - принудительноя или простая для конкретного шаблона запроса, перекрывая настройки базы данных (sp_get_query_template имитирует параметризованную форму запроса, получаемую в результате принудительной параметризации).
    
Функция sys.fn_validate_plan_guide проверяет правильность указанного руководства по плану.

В плане можно определить применение руководства плана с помощью полей PlanGuideDB и PlanGuideName.

SQL Server отделяет кеш-план в четырех разных областях памяти, называемых хранилищами кешей. Каждое кэш-хранилище кэширует разные объекты и планы следующим образом:
    - В хранилище кеша SQL-планов (внутреннее имя CACHESTORE_SQLCP) хранятся планы для параметризованных и специальных запросов и партий, а также для планов с автоматической параметризацией.
    - В хранилище кеша объектов (CACHESTORE_OBJCP) хранятся планы объектов T-SQL, такие как хранимые процедуры, триггеры и пользовательские функции.
    - В хранилище кешей расширенных хранимых процедур (CACHESTORE_XPROC) хранятся планы расширенных хранимых процедур.
    - В хранилище кешей связаных деревьев (CACHESTORE_PHDR) хранит связаные деревья, сгенерированные на этапе оптимизации запросов. Связанные деревья - это структуры, создаваемые алгебратором SQL Server для представлений, ограничений и значений по умолчанию.

Хранилища кешей можно просмотреть с помощью предствления sys.dm_os_memory_cache_counters, cвойства кэша можно просмотреть с помощью представления sys.dm_os_memory_cache_hash_tables.

SQL Server начинает удалять планы из кеша в случае давления памяти. Существует два типа давления памяти: локальное и глобальное.
Как локальное, так и глобальное давление памяти устраняет планы из кеша, используя алгоритм, называемый политикой выселения, который основан на стоимости плана.
Когда общий размер всех кэшированных планов достигает 50 процентов от размера буферного пула, SQL Server запускает процесс который начинает периодически сканировать кеш плана, уменьшая стоимость каждого плана при каждом сканировании и удаляет планы с нулевой стоимостью (каждое повторное использование плана увеличивает его стоимость).

SQL Server не кэширует планы хранимых процедур, 
которые используют BULK INSERT или OPENROWSET (BULK), 
такие процедуры компилируются при каждом выполнении.

SQL Server не кэширует планы хранимых процедур, 
которые используют внешние временные таблицы.

Чтобы обеспечить эффективное использование кеша плана, следуйте этим рекомендациям:
    - Не чередуйте заявления DDL и DML.
        В хранимых процедурах операторы DDL часто используются для создания локальных временных таблиц и для изменения их схемы (включая добавление индексов). 
        Это может повлиять на действительность существующего плана и может вызвать перекомпиляцию, когда выполняются операторы хранимой процедуры, относящиеся к таблицам.
    - Явно параметризируйте переменные части запроса.
    - Используйте хранимые процедуры для реализации бизнес-функций.
    - Используйте sp_executesql, чтобы избежать обслуживания хранимых процедур.
    - Используйте модель подготовки/выполнения, чтобы избежать повторной отправки строки запроса.
    - Избегайте специальных запросов.
    - Используйте sp_executesql вместо EXECUTE для динамических запросов.
    - Параметрируйте переменные части запросов с осторожностью.
    - Избегайте изменения настроек среды между соединениями.
    - Избегайте неявного разрешения объектов в запросах.
    - Избегайте изменения параметров SET в хранимой процедуре.
        Вы можете избежать перекомпиляции, вызванной некоторыми из этих изменений настроек SET, 
        путем сброса параметров подключения, перед вызовом хранимой процедуры.
    - Избегайте перекомпиляции, вызванной изменениями статистики.
        Есть два способа избежать перекомпиляции, вызванных изменением статистики:
            - Подсказка KEEPFIXED PLAN.
            - Отключение функции автоматической обновления статистики в таблице.    