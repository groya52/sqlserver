Внешняя фрагментация возникает, когда логически последующие страницы данных не расположены в том же или соседнем экстенте.
Внутренняя фрагментация происходит, когда страницы данных уровня листа в индексе имеют свободное пространство.

Получить информацию о фрагментации можно из DMO sys.dm_index_physical_stats.

Уровень фрагментации может быть настолько серьезным, 
что оптимизатор запросов перестанет использовать индекс в планах запросов.

Другой негативный эффект, который может иметь фрагментация на производительность, связан с непрерывными чтениями. 

Фрагментацию может вызвать:
    INSERT
    UPDATE
        Если страница данных имеет достаточно свободного места для размещения новой строки или внесения изменений в строку,
        SQL Server просто вставляет новую строку или изменяет строку.
        
        Однако, если на странице данных недостаточно свободного места, происходит следующее:
            - Будет выделена новая страница данных и, при необходимости, новый экстент.
            - Некоторые данные со старой страницы данных перемещаются на вновую выделенную страницу.
            - Указатели предыдущей и следующей страницы обновляются, чтобы поддерживать логический порядок сортировки в индексе.
    DELETE
        Удаляет страницы с индекса, образуются пробелы (внешняя фрагментация).
        
        Когда строки удаляются из кучи, страницы, связанные с этими строками (раздувание внутри кучи).
        Страницы, в которых ранее хранились данные, становятся доступным для будущих вставок в таблицу.
    DBCC SHRINKDATABASE
        Страницы в конце файла данных перемещаются в начало.
    
Учитывать фрагментацию в кластерном и некластерном индексе.
    
Куча:
    - Удаление записей, оставляет пустое место, что может привести к избыточному чтению,
      если пустое место не будет заполнятся данными.
    - Forwarding.
    
Проблемы:
    - Ввод-вывод.
    - Упреждающие чтения (система пытается предугадать, 
      какие именно страницы данных и индексов понадобятся для плана выполнения запроса, 
      и помещает эти страницы в буферный кэш, прежде, чем в них возникнет реальная необходимость).
    
CREATE INDEX DROP_EXISTING
    - Необходимо изменить определение индекса (добавить или удалить столбцы или изменить их порядок).
    - Индекс необходимо перенести из одной файловой группы в другую.
    - Необходимо изменить секционирование индекса.
    
    Недостатки:
        - Блокировка. 
          Подобно методам DROP и CREATE, этот метод также вызывает и блокирует блокирование от других запросов, 
          обращающихся к таблице (или любому индексу в таблице).
        - Индекс с ограничениями. 
          Может использоваться для воссоздания индексов с ограничениями.
          Если ограничение является первичным ключом или уникальное ограничение связано с внешним ключом, 
          то отказ от включения ключевого слова UNIQUE в оператор CREATE приведет к ошибке.
        - Все индексы на таблице должны быть идентифицированы и перестроены индивидуально.
        
    Вы можете использовать предложение DROP_EXISTING как для кластеризованных, так и для некластеризованных индексов, 
    и даже для преобразования некластеризованного индекса в кластеризованный индекс.
    Однако вы не можете использовать его для преобразования кластерного индекса в некластеризованный индекс.
    
ALTER INDEX REBUILD (индексы, фрагментированные болле 30 процентов)
    - В одном заявлении можно перестроить более одного индекса.
    - Можно перестроить одну секцию индекса.
    
    Недостатки:
        - Вводит блокировку в систему. 
          Он блокирует все другие запросы, 
          пытающиеся получить доступ к таблице (или любому индексу в таблице).
          
          Вы можете запустить ALTER INDEX REBUILD с помощью ключевого слова ONLINE, 
          что уменьшит механизмы блокировки, но это увеличит время, затрачиваемое на восстановление индекса.
        - Откат транзакции. 
          Поскольку ALTER INDEX REBUILD полностью атомарен в действии, если он остановлен до завершения, 
          то все действия по дефрагментации, выполненные до этого времени, будут потеряны. 
    
    Секционированные индексы нельзя перестраивать в ONLINE.
    
    Заменяет старый фрагментированный индекс новой копией. 
    Когда новый индекс будет завершен, существующий индекс будет удален.
    
    По умолчанию это автономная операция (SQL Server Enterprise, Developer и Evaluation. может перестраивать индексы онлайн), 
    и SQL Server получает и сохраняет блокировку таблиц схемы (Sch-M) на время действия.
    
    Для восстановленного индекса в базе данных должно быть минимум 120 процентов от текущего индекса.
    Причиной этого является то, что текущий индекс не будет сброшен до завершения перестройки.
        
    Существует два способа уменьшить часть пространства, необходимого для индекса во время REBUILD:
        - SORT_IN_TEMPDB можно использовать для уменьшения объема пространства, 
          необходимого для промежуточных результатов (20-процентный буфер не понадобится).
        - Отключить индекс до восстановления (применяется только к некластеризованным индексам). 
          Это позволит перестроить индекс в пространстве, который ранее занимал индекс.
    
ALTER INDEX REORGANIZE (индексы, фрагментированные менее 30 процентов)
    - Онлайн-операция, которая может быть отменена в любое время без потери ее прогресса.
    - Минимальное использование ресурсов.
    
    Чтобы избежать накладных расходов блокировки, связанных с ALTER INDEX REBUILD, 
    этот метод использует неатомный онлайн-подход. 
    
    По мере выполнения своих шагов он запрашивает небольшое количество блокировок в течение короткого периода времени. 
    Как только каждый шаг выполняется, он освобождает блокировки и переходит к следующему шагу.
    При попытке доступа к странице, если она обнаруживает, 
    что страница используется, она пропускает эту страницу и больше не возвращается на страницу.
    
    Это позволяет выполнять другие запросы на столе вместе с операцией ALTER INDEX REORGANIZE.
    Кроме того, если эта операция останавливается промежуточно, 
    то все шаги дефрагментации, выполненные до этого, сохраняются.
    
    Если индекс охватывает несколько файлов, ALTER INDEX REORGANIZE не переносит страницы между файлами.
    Однако основным преимуществом использования ALTER INDEX REORGANIZE является то, 
    что он позволяет другим запросам одновременно обращаться к таблице (или индексам).
       
    Индекс доступен для использования оптимизатором в новом плане выполнения или в кэшированных планах выполнения на время REORGANIZE.
    
    Недостатком реорганизации индекса является то, 
    что реорганизация использует только страницы данных, уже выделенные для индекса.
    
    При фрагментации малых индексов (cтраницы индексов малого размера хранятся в смешанных экстентах), 
    экстенты, выделенные одному индексу, часто могут быть переплетены с экстентами, выделенными для других индексов.    
    Переупорядочение страниц данных не приведет к тому, что страницы данных будут более смежными, чем в настоящее время, 
    но он будет уверен, что выделенные страницы отсортированы в том же порядке, что и сами данные.
    
    Пытается скомпоновать страницы, уменьшая их внутреннюю фрагментацию.
    
    Позволяет реорганизовать один раздел, опция REBUILD не позволяет этого.
 
Блокировки с низким приоритетом.
    SQL Server 2014 представил концепцию блокировок с низким приоритетом,
    которые могут улучшить параллелизм в системе во время онлайн перестроения индексов и операций переключения секций.
    
    Во время процесса перестройки для блокировки таблиц используется блокировка намерения (IS),
    текже необходимо получить блокировку таблицы общего доступа (S) в начале и блокировку схемы (Sch-M) на последнем этапе выполнения.
    Обе блокировки удерживаются в течение очень короткого времени, 
    однако они могут вводить проблемы блокировки при нагруженных системах.
    
    Когда начинаеся перестроение индекса онлайн, 
    и присутствует другая активная транзакция, изменяющая данные в таблице.    
    Эта первоначальная транзакция будет содержать блокировку намерения (IX) на таблице, 
    что предотвращает перестройку индекса онлайн при приобретении общей блокировки таблицы (S).
    Запрос блокировки будет ждать в очереди и блокировать все другие транзакции, 
    которые хотят изменить данные в таблице, так как им все равно необходимо приобрести блокировку намерения (IX).
    Это условие блокировки очищается только после завершения первой транзакции, 
    и онлайновая перестройка индекса получает и освобождает блокировку таблицы общего доступа (S).
    Подобное условие блокировки может возникать на заключительном этапе восстановления индекса онлайн, 
    когда ему необходимо получить блокировку схемы (Sch-M), чтобы заменить ссылку индекса в метаданных.
    Как читатели, так и писатели будут заблокированы, 
    в то время как восстановление индекса ждет изменения блокировки схемы (Sch-M). 
    
    Блокировки с низким приоритетом не блокируют другие сеансы, которые хотят приобретать несовместимые блокировки, 
    пока они ждут, чтобы такие блокировки были приобретены.
    
    Можно указать приоритет блокировки с помощью параметра WAIT_AT_LOW_PRIORITY в инструкции ALTER INDEX или ALTER TABLE.
 
Третий способ дефрагментации индекса - просто отбросить индекс и заново создать его.
    Недостатки:
        - Добавляет большое количество накладных расходов в системе и вызывает блокировку.
          Отбрасывание и повторное создание индекса блокирует все остальные запросы в таблице (или по любому другому индексу в таблице).
          Он также может быть заблокирован другими запросами к таблице.
        - Если индекс является кластеризованным индексом, тогда все остальные индексы необходимо будет перестроить, 
          когда кластеризованный индекс будет сброшен.
          Это приводит к дальнейшим блокировкам и другим проблемам, таким как перекомпиляция оператора.
        - Уникальные ограничения. 
          Индексы, которые используются для определения первичного ключа или уникального ограничения, 
          не могут быть удалены с помощью инструкции DROP INDEX. 
          Кроме того, как уникальные ограничения, так и первичные ключи могут ссылаться на ограничения внешнего ключа.
          Перед отбрасыванием первичного ключа сначала необходимо удалить все внешние ключи, которые ссылаются на первичный ключ.
        - Необходимо учесть все свойства индекса.
        - После удаления индекса из этой таблицы его нельзя использовать.
          Если индекс удален и, возможно, был заблокирован и ожидает повторного создания, 
          запросы к таблице не будут иметь индекс, доступный для использования.
          Это может привести к низкой производительности, которую индекс должен был исправить.
      
    Можно использовать опцию ONLINE для удаления кластерного индекса, 
    что означает, что индекс все еще доступен для чтения во время его удаления, 
    но это устраняет только проблему блокировки.
    
Если сжатие указано в индексе, даже в секционированном индексе, 
вы должны обязательно установить сжатие при выполнении операции ALTER INDEX до того, что было раньше, 
если вы этого не сделаете, он будет потерян, и вам придется снова перестроить индекс.
Это особенно важно для некластеризованных индексов, которые не будут наследовать параметр сжатия из таблицы.
    
Реорганизуйте (REORGANIZE) индексы с фрагментацией менее 30 процентов.
Перестройте (REBUILD) индексы с 30% или более фрагментацией.
Игнорировать индексы, которые имеют менее 1000 страниц.
Если Enterprise Edition, используйте онлайн-перестройки, когда данные должны быть доступны во время обслуживания.
Если кластеризованный индекс перестраивается, перестройте все индексы в таблице.

Не используйте FILLFACTOR = 100 в тех случаях,
когда база данных использует оптимистические уровни изоляции транзакций и/или если таблица емеет AFTER UPDATE или AFTER DELETE триггеры.

Лучше REORGANIZE, а не REBUILD индексы после завершения операции SHRINK.
Перестройка индекса создает другую копию индекса, которая увеличивает размер файла данных и наносит ущерб цели сжатия.

Чтобы поддерживать связь между новой и старой версиями строк,
триггеры AFTER UPDATE и AFTER DELETE добавляют 14-байтовый указатель тега версии для строк, 
которые они модифицировали или удалили, и они останутся до тех пор, пока индекс не будет восстановлен.
Это может увеличить размер строки и ввести фрагментацию.

В качестве альтернативы процессу сжатия вы можете создать новую файловую группу и воссоздать индексы, перемещая туда объекты.
После этого можно удалить старую и пустую файловую группу.
Этот подход уменьшает размер базы данных таким же образом, как и сжатие без введения фрагментации.

Отслеживать операции разделения страниц в режиме реального времени с помощью расширенных событий.

Предотвращение фрагментации:
    - Коэффициент заполнения (FILLFACTOR).
    - Ввод данных.

Шаги, которые скрипт будет выполнять, для дефрагментации индексов:
    1. Собирать данные о фрагментации индексов.
    2. Определить, индексы для дефрагментации.
    3. Создать инструкцию дефрагментации.