Каждая транзакция в правильно реализованной системе управления транзакциями имеет четыре различные характеристики (ACID):
    - Атомарность (Atomicity).
        Гарантирует, что каждая транзакция выполняется как все или ничего.
    - Согласованность (Consistency).
        Гарантирует, что любая транзакция базы данных приведет базу данных из одного согласованного состояния в другое.
    - Изолированность (Isolation).
        Гарантирует, что изменения, сделанные в транзакции, изолированы и невидимы для других транзакций, пока транзакция не будет совершена.
    - Устойчивость (Durability).
        Гарантирует, что после совершения транзакции все изменения, сделанные транзакцией сохраняются, даже если происходит сбой системы.

Вы можете контролировать уровни изоляции и поведение блокировки на уровне транзакции, 
используя оператор SET TRANSACTION ISOLATION LEVEL или на уровне таблицы с помощью подсказки.
Также можно использовать разные уровни изоляции в одном запросе для каждой таблицы.

Когда приложения не запускают явные транзакции с операторами BEGIN TRAN/COMMIT TRAN, 
SQL Server использует неявные транзакции на протяжении всех операторов.

Инструкции SELECT выполняются в рамках своих легких транзакций, 
SQL Server не записывает их в журнал транзакций.
            
Вы можете контролировать, как долго SQL Server ожидает, 
что блокировка будет выпущена,  используя параметр сеанса LOCK_TIMEOUT.
Это опция SET, поэтому поведение можно контролировать только для отдельного сеанса. 
Вы не можете установить значение LOCK_TIMEOUT для SQL Server в целом.
            
Категории блокировок.
    Эксклюзивные (X) блокировки.
        Исключительные (X) блокировки приобретаются писателями - инструкции INSERT, UPDATE, DELETE и MERGE, 
        которые модифицируют данные. 
        
        Эти запросы приобретают эксклюзивную (X) блокировку в затронутых строках и удерживают их до конца транзакции.
        Только один сеанс может содержать эксклюзивную (X) блокировку ресурса в любой момент времени. 
        
        Уровни изоляции транзакций не влияют на поведение эксклюзивной (X) блокировки.        
    Блокировки намерения (I).
        Блокировки намерения хранятся на страницах данных и таблицах, 
        и они указывают на наличие блокировок на дочерних объектах.        
    Блокировки обновления (U).
        SQL Server использует блокировку обновления (U) при изменении данных, 
        приобретая их при поиске строк, которые необходимо обновить (см. риc. Блокировки обновления (U) и эксклюзивные блокировки (X).jpg).
        
        После приобритения блокировки обновления (U) SQL Server считывает строку и оценивает, 
        нужно ли обновлять строку, проверяя данные строки на предикаты запроса.        
        Если это так, SQL Server преобразует блокировку обновления (U) в исключительную (X) блокировку и выполняет модификацию данных.
        В противном случае блокировка обновления (U) будет отменена.
        
        Изменение поведения блокировки обновления (U) зависит от плана выполнения.
        
        В некоторых случаях SQL Server сначала получает блокировки обновления (U) для всех строк, 
        а затем переводит их в блокировки (X).
        
        В других случаях - когда, например, обновляется одна строка на основе кластерного значения индекса, 
        SQL Server может приобрести эксклюзивную блокировку (X) без использования блокировки обновления (U).
    Общие (S) блокировки.
        Общие (S) блокировки приобретаются читателями - инструкция SELECT. 
        
        Общие (S) блокировки совместимы друг с другом, 
        а несколько сеансов могут содержать блокировки общего (S) доступа на одном и том же ресурсе.
        
        Поведение общих (S) блокировок зависит от уровня изоляции транзакции.
        
Совместимость блокировок см. рис. Совместимость блокировок.jpg.

Пессимистические уровни изоляции транзакций и поведение общих (S) блокировок.

    Уровень изоляции  Подсказка                Поведение
                                               
    READ UNCOMMITTED  NOLOCK                   Блокировки не получены.
                                               
    READ COMMITTED    READCOMMITTED            Блокировки, приобретенные и выпущенные немедленно.
                                               
    REPEATABLE READ   REPEATABLEREAD           Блокировки, приобретенные и удерживаемые до конца транзакции.

    SERIALIZABLE      SERIALIZABLE или XLOCK   Блокировки диапазона, приобретенные и удерживаемые до конца транзакции.

    На уровне изоляции READ UNCOMMITTED общие (S) блокировки не приобретаются. 
    Поэтому читатели могут читать строки, которые были изменены другими сеансами, 
    и иметь на них эксклюзивные (X) блокировки.

    В уровне изоляции READ COMMITTED SQL Server получает и освобождает блокировки общего доступа (S) сразу после чтения строки.
    В некоторых случаях в режиме READ COMMITTED SQL Server может хранить блокировки общего доступа (S) на протяжении всего оператора SELECT.
    Одним из таких примеров является запрос, который считывает данные LOB из таблицы.        

    На уровне изоляции REPEATABLE READ SQL Server получает блокировки общего доступа (S) и удерживает их до конца транзакции.
    Это гарантирует, что другие сеансы не смогут изменять данные после их чтения.

    На уровне изоляции SERIALIZABLE блокировки общего доступа (S) сохраняются до конца транзакции. 
    Однако SQL Server использует другой вариант блокировок, называемых блокировками диапазона (см. рис. Поведение общих (S) блокировок на уровне изоляции SERIALIZABLE.jpg).
            
Уровни изоляции транзакций и согласованность данных (см. рис. Уровни изоляции транзакций и согласованность данных.jpg).
    
    Грязные чтения (Dirty Reads).
        Эта проблема возникает, когда транзакция считывает незафиксированные (грязные) данные из других незафиксированных транзакций. 
        
    Неповторяемые чтения.
        Последующие попытки чтения одних и тех же данных из одной транзакции возвращают разные результаты.
        Эта проблема несогласованности данных возникает, когда другие транзакции изменяют или даже удаляют данные между чтениями.
        
    Фантомные чтения.
        Это явление возникает, когда последующие чтения внутри одной транзакции возвращают новые строки (те, которые транзакция ранее не читала). 
    
    Два других явления связаны с перемещением данных из-за изменения значения ключа индекса:
        
        Дублированные чтения.
            Эта проблема возникает, когда запрос возвращает одну и ту же строку несколько раз.
            Это может произойти в ситуации, где строки были перемещены из обработанной в необработанную часть индекса.
            
        Пропущенные строки.
            Это явление возникает, когда запросы не возвращают некоторые из строк. 
            Это может произойти в ситуации, где строки были перемещены из необработанной в обработанную часть индекса.
            
                     Грязные   Невосстановимые  Дублированные  Фантомные  Пропущенные
                     чтения    чтения           чтения         чтения     строки
    
    READ UNCOMMITTED Да        Да               Да             Да         Да
                                                                          
    READ COMMITTED   Нет       Да               Да             Да         Да
                                                                          
    REPEATABLE READ  Нет       Нет              Нет            Да         Да

    SERIALIZABLE     Нет       Нет              Нет            Нет        Нет

Оптимистические уровни изоляции.
    С оптимистическими уровнями изоляции транзакций, когда происходят операции UPDATE и DELETE, 
    SQL Server хранит старые версии строк в специальной части tempdb, называемой хранилищем версий (version store), 
    и сохраняет эти копии до тех пор, пока существуют какие-либо транзакции, которым может потребоваться доступ к этим строкам.
    В зависимости от ситуации может быть более одной записи версии строки, хранящейся в хранилище версий строк.
    
    Операции INSERT обычно не генерируют версии строк, некоторых случаях, 
    если вы вставляете строку в таблицу с уникальным индексом и если более старая версия строки имеет тот же ключ значение как новая строка, 
    и эта старая строка все еще существует как призрак, новая строка генерирует версию строки.
    
    Задача очистки хранилища версий запускается один раз в минуту, 
    а также перед событием автоматического роста, если tempdb заполнен.
    
    К исходным строкам в базе данных добавляется 14-байтовый указатель (фактический указатель на файл, 
    страницу и строку в tempdb требуется 8 байтов, а 6 байтов необходимы для хранения XSN), 
    которые ссылаются на старые версии строк.
    
    Если страница плотно упакована и новая версия строки не вписывается в страницу, 
    это приведет к разделению страницы и дальнейшей фрагментации.
    Эти 14 байтов остаются в строке, даже после того, 
    как записи будут удалены из хранилища версий до тех пор, 
    пока индекс не будет перестроен.
        
    Когда строка в таблице или индексе обновляется, 
    новая строка маркируется порядковым номером транзакции (XSN), выполняющей обновление.
    XSN является монотонно увеличивающимся числом, 
    уникальным в каждой базе данных SQL Server.
               
    Хотя оптимистические уровни изоляции помогают уменьшить блокировку, 
    также они способствуют загрузке tempdb.
    На высоконагруженных системах может привести к очень тяжелой активности tempdb и может значительно увеличить размер tempdb.
    
    SQL Server необходимо скопировать данные в tempdb, 
    а также сохранить связанный список записей версий.
    Аналогично, при чтении данных он должен проходить этот список, 
    что добавляет дополнительную нагрузку на CPU и I/O.
       
    Когда строка удаляется в базе данных, включенной для моментальных снимков, 
    указатель остается на странице в качестве записи призрака, 
    чтобы указать на удаленную строку в хранилище версий.
    Они очищаются как часть процесса очистки версий.    
    Заголовок записи указывает, 
    что эта строка является GHOST_VERSION_RECORD и содержит информацию о версии. 
    Фактические данные, однако, не находятся в строке, 
    но XSN есть, поэтому транзакции моментальных снимков знают, 
    когда эта строка была удалена, 
    и должны ли они получить доступ к более старой версии ее в своем снимке.
       
    Существует два оптимистических уровня изоляции транзакций:
        READ COMMITTED SNAPSHOT (см. https://www.safaribooksonline.com/library/view/pro-sql-server/9781484219645/A313962_2_En_21_Chapter.html#Sec3).
            Уровень изоляции READ COMMITTED SNAPSHOT (RCSI) можно включить с помощью команды ALTER DATABASE SET READ_COMMITTED_SNAPSHOT ON.
            Включение, требует эксклюзивную (X) блокировку базы данных и оно будет заблокировано, если к базе данных будут подключены другие пользователи.
                        
            Изменяет поведение читателей на уровне изоляции транзакций READ COMMITTED.
            
            READ COMMITTED SNAPSHOT обеспечивает согласованность на уровне инструкций (запрос считывает моментальный снимок данных во время запуска оператора).
            
            READ COMMITTED SNAPSHOT не требует каких-либо изменений кода и может использоваться как аварийный метод, 
            когда система испытывает проблемы с блокировкой.
            
            RCSI обеспечивает согласованность на уровне инструкций, поэтому таблицы из двух разных баз данных, 
            на которые ссылается один и тот же запрос, могут иметь свои собственные индивидуальные настройки. 
            Одна таблица может получать свои данные из хранилища версий,
            в то время как другая таблица считывает только текущие версии данных. 
            Обе базы данных не обязательны для включения опции RCSI.
            
        SNAPSHOT (см. https://www.safaribooksonline.com/library/view/pro-sql-server/9781484219645/A313962_2_En_21_Chapter.html#Sec4)
            Уровень изоляции SNAPSHOT можно включить с помощью инструкции ALTER DATABASE SET ALLOW_SNAPSHOT_ISOLATION ON.
            Этот оператор не требует исключительной блокировки базы данных и может быть выполнен с другими пользователями, подключенными к базе данных.
            
            Необходимо явно указывать в коде с помощью инструкции SET TRANSACTION ISOLATION LEVEL SNAPSHOT или с помощью подсказки таблицы WITH (SNAPSHOT).
            
            SNAPSHOT обеспечивает согласованность на уровне транзакций (запрос обращается к моментальному снимку данных во время начала транзакции).
            
            С уровнем изоляции SNAPSHOT писатели не блокируют друг друга, за исключением ситуации, когда оба сеанса обновляют одни и те же строки. 
            Такая ситуация приводит либо к блокировке, либо к ошибке 3960.
            
            Если приложение запускает транзакцию моментального снимка, которая обращается к таблицам из двух баз данных, 
            администратор базы данных должен включить ALLOW_SNAPSHOT_ISOLATION в обеих базах данных до того, 
            как приложение запустит транзакцию моментального снимка.
        
    Следующие операторы DDL запрещены в транзакции SI:
        - CREATE | ALTER | DROP INDEX
        - DBCC DBREINDEX
        - ALTER TABLE
        - ALTER PARTITION FUNCTION | SCHEME
        
    Когда оператор DDL вне транзакции SI изменяет объект, на который ссылается транзакция SI, SQL Server генерирует ошибку 3961.
        
    SQL Server использует уровень изоляции READ COMMITTED при проверке ограничений внешнего ключа. 
    Это означает, что у вас все еще есть блокировка между писателями и читателями даже с оптимистичными уровнями изоляции.
    
    Отслеживание поведения хранилища версий.
        SQL Server:Transactions
            https://technet.microsoft.com/en-us/library/ms189038(v=sql.105).aspx
            
        DMVs
            https://technet.microsoft.com/en-us/library/ms178621(v=sql.110).aspx
      

Совместимость с несколькими сеансами и блокировкой (см. https://www.safaribooksonline.com/library/view/pro-sql-server/9781484219645/A313962_2_En_23_Chapter.html#Sec2 или _Books\Pro SQL Server Internals, 2nd Edition.pdf стр. 449).

Архитектура блокировки (см. https://www.safaribooksonline.com/library/view/microsoft-sql-server/9780735670174/ch13s04.html#internal_locking_architecture).
            
Эскалация блокировки.
    В памяти структура блокировки использует 64 байта в 32-битных и 128 байт в 64-разрядных операционных системах.
        
    Эскалация блокировки происходит в следующих ситуациях:
        - Количество блокировок, удерживаемых одним оператором на одном объекте или на одном разделе одного объекта, превышает пороговое значение. 
          Этот порог составляет 5000 блокировок, но он может измениться в будущих пакетах обновлений.
          
          Если операция не удалась, SQL Server продолжает использовать попытки блокировки на уровне строк и повторяет операцию после каждых 1250 новых блокировок.    
          
          Фактическое количество приобретенных блокировок, которое вызывает эскалацию блокировки, меняется.        
        - Память, занятая ресурсами блокировки, превышает 24 процента памяти, используемой механизмом базы данных.
    
    Операция будет успешной, если никакие другие сеансы не будут содержать несовместимые блокировки объекта или раздела.
        
    Эскалация блокировки инициируется количеством блокировок, полученных оператором, а не транзакцией.
    
    Если отдельные операторы получают менее 5000 блокировок на уровне строк и страниц, 
    блокировка эскалации не запускается, независимо от общего количества блокировок, выполняемых транзакцией.
    
    Можно контролировать поведение эскалации на уровне таблицы, используя инструкцию ALTER TABLE SET LOCK_ESCALATION.
    
        DISABLE
            Отключает эскалацию блокировки для конкретной таблицы.
        TABLE
            SQL Server переводит блокировки на уровень таблицы.
        AUTO
            SQL Server повышает уровень блокировки на уровнь раздела, когда таблица разбита на разделы или на уровень таблицы, когда таблица не разбита на разделы.
            Используйте этот параметр с большими секционированными таблицами, особенно когда на старых данных выполняются большие отчеты.
    
    SQL Server поддерживает отмену эскалации блокировки с использованием флагов трассировки. Эти флаги трассировки влияют на весь экземпляр SQL Server:
        T1211
            Полностью отключает эскалацию блокировки и позволит блокировать память до 60% динамически распределенной памяти, а затем последующая блокировка завершится сбоем, ошибка памяти.
        T1224 
            Отключает эскалацию блокировки на основе количества приобретенных блокировок, но позволяет эскалацию на основе потребления памяти 40%.
    
        Если оба флажка трассировки установлены одновременно, флаг трассировки 1211 имеет приоритет.
    
    Подсказка WITH (ROWLOCK) не влияет на поведение эскалации блокировки.
      
Блокировки с низким приоритетом.
    SQL Server 2014 представил концепцию блокировок с низким приоритетом, 
    которые могут улучшить параллелизм в системе во время онлайн перестроения индексов и операций переключения секций.
    
    Во время процесса перестройки для блокировки таблиц используется блокировка намерения (IS),
    текже необходимо получить блокировку таблицы общего доступа (S) в начале и блокировку схемы (Sch-M) на последнем этапе выполнения.
    Обе блокировки удерживаются в течение очень короткого времени, однако они могут вводить проблемы блокировки при нагруженных системах.
    
    Когда начинаеся перестроение индекса онлайн, и присутствует другая активная транзакция, изменяющая данные в таблице.
    Эта первоначальная транзакция будет содержать блокировку намерения (IX) на таблице, что предотвращает перестройку индекса онлайн при приобретении общей блокировки таблицы (S).
    Запрос блокировки будет ждать в очереди и блокировать все другие транзакции, которые хотят изменить данные в таблице, так как им все равно необходимо приобрести блокировку намерения (IX).
    Это условие блокировки очищается только после завершения первой транзакции, и онлайновая перестройка индекса получает и освобождает блокировку таблицы общего доступа (S).
    Подобное условие блокировки может возникать на заключительном этапе восстановления индекса онлайн, когда ему необходимо получить блокировку схемы (Sch-M), чтобы заменить ссылку индекса в метаданных.
    Как читатели, так и писатели будут заблокированы, в то время как восстановление индекса ждет изменения блокировки схемы (Sch-M).
    
    Блокировки с низким приоритетом не блокируют другие сеансы, которые хотят приобретать несовместимые блокировки, пока они ждут, чтобы такие блокировки были приобретены.
    
    Можно указать приоритет блокировки с помощью параметра WAIT_AT_LOW_PRIORITY в инструкции ALTER INDEX или ALTER TABLE.
    
Блокировки приложений (Application Locks) (см. https://www.safaribooksonline.com/library/view/pro-sql-server/9781484219645/A313962_2_En_22_Chapter.html или _Books\Pro SQL Server Internals, 2nd Edition.pdf стр. 443).
    Блокировки приложений позволяют приложению блокировать ресурс приложения, который не связан с объектами базы данных и идентифицируется только по имени.
    
    Может быть очень полезно в тех случаях, когда необходимо предотвратить параллельный запуск некоторого кода.
      
    sp_getapplock 
        Размещает блокировку на ресурсе приложения. 
    sp_releaseapplock
        Снимает блокировку ресурса приложения.
  
Блокировки схемы.
    SQL Server использует два дополнительных типа блокировок, называемых блокировками схем,
    для предотвращения изменения таблиц и метаданных во время выполнения запроса.
        
    Блокировки стабильности схемы (Sch-S).
        Блокировка стабильности схемы (Sch-S) используется во время компиляции и выполнения запроса DML.
        Блокировки стабильности схемы (Sch-S) совместимы с любым блокировками, 
        кроме блокировки модификации схемы (Sch-M).
    
    Блокировки модификации схемы (Sch-M).
        Приобретаются до изменения любых метаданных и во время выполнения инструкции TRUNCATE TABLE.
        
        Несовместимы с любыми другими типами блокировок и полностью блокирует доступ к объекту, 
        удерживается до конца транзакции.
        Необходимо помнить об этом при запуске DDL операторов в явных транзакциях.
        
        Хотя явная транзакция позволяет откатить все изменения схемы в случае ошибки, 
        она также предотвращает любой доступ к затронутым объектам до тех пор, 
        пока транзакция не будет выполнена.

        SQL Server также использует блокировки модификации схемы (Sch-M) при изменении функции секционирования.
        Это может серьезно повлиять на доступность системы, 
        когда такие изменения приводят к перемещению данных или сканированию.
        
        То же самое можно сказать и при перестраивании индекса онлайн. 
        Несмотря на то, что во время процесса перестройки для блокировки таблиц используется блокировка намерения (IS),
        ему необходимо получить блокировку таблицы общего (S) доступа в начале и блокировку схемы (Sch-M) на последнем этапе выполнения.
        Оба замка удерживаются в течение очень короткого времени, однако они могут вводить проблемы блокировки при нагруженных системах.
                      
Подсказка READPAST позволяет сеансам пропускать строки с несовместимыми блокировками, а не блокироваться.