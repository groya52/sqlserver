Существует системная задача Deadlock Monitor, которая просыпается каждые пять секунд и проверяет наличие каких-либо взаимоблокировок в системе.
При возникновении взаимоблокировок интервал обнаружения взаимоблокировки уменьшается и может достигать 100 миллисекунд.

Выбор того, какой сеанс выбран для отката транзакции, если произошла взаимоблокировка, зависит от нескольких вещей.
SQL Server пытается пожертвовать процессом, который будет наименее дорогостоящим для откат, учитывая объем работы, которую этот процесс уже выполнил.

Используя инструкцию SET DEADLOCK_PRIORITY, 
процесс может определить приоритет для отката транзакции, если произошла взаимоблокировка с другим сеансом.

Классический тупик (см. https://www.safaribooksonline.com/library/view/pro-sql-server/9781484219645/A313962_2_En_19_Chapter.html#Sec1).
    Классический тупик возникает, когда два или более сеансов конкурируют за один и тот же набор ресурсов (см. рис. Классический тупик.jpg).
    
Взаимоблокировка из-за неоптимизированных запросов (см. https://www.safaribooksonline.com/library/view/pro-sql-server/9781484219645/A313962_2_En_19_Chapter.html#Sec2).
    Происходят из-за сканирования, вызванного неоптимизированными запросами (см. рис. Взаимоблокировка из-за сканирования.jpg).
    
    Способы решения:
        - Оптимизация запросов помогает устранить взаимоблокировки, вызванные сканированием и неоптимизированными запросами.
    
Взаимоблокировка поиска ключа (key lookup) (см. https://www.safaribooksonline.com/library/view/pro-sql-server/9781484219645/A313962_2_En_19_Chapter.html#Sec3).
    Когда несколько сеансов пытаются читать и обновлять одну и ту же строку одновременно (см. рис. Взаимоблокировка поиска ключа (key lookup).jpg).
     
    Способы решения:
        - Создание некластеризованного покрывающего индекса и предотвращение операции поиска ключа (key lookup).
        - Использовать оптимистические уровни изоляции.
        
Взаимоблокировка из-за нескольких обновлений одной и той же строки (см. https://www.safaribooksonline.com/library/view/pro-sql-server/9781484219645/A313962_2_En_19_Chapter.html#Sec4).
    Происходят из-за нескольких обновлений одной и той же строки, если последующее обновление обращается или изменяет столбцы в разных некластеризованных индексах.
    
    Способы решения:
        - Устранить несколько обновлений одних и тех же строк.
    
Взаимоблокировка из-за конвертации блокировки (см. https://www.safaribooksonline.com/library/view/microsoft-sql-server/9780735670174/ch13s02.html#conversion_deadlocks).
    Процесс A и процесс B имеют общую (S) блокировку на одной и той же странице в транзакции. 
    Каждый процесс хочет конвертировать свою общую (S) блокировку в эксклюзивную (X) блокировку, 
    но не может этого сделать из-за блокировки другого процесса (см. рис. Взаимоблокировка из-за конвертации блокировки.png).

    Если заранее известно, что процессам, возможно, потребуется обновить строку после ее чтения, они должны сначала запросить блокировку обновления (U), а не общую блокировку. 
    Если оба процесса запрашивают блокировку обновления (U), а не общую (S) блокировку, процессу, которому предоставлена ​​блокировка обновления (U), гарантируется, 
    что блокировка может быть впоследствии повышена до эксклюзивной (X) блокировки. Другой процесс, требующий блокировки обновления (U), должен ждать.
    
Взаимоблокировка модификации схемы.
    Происходит из-за смешивания блокировки модификации схемы, с другими типами блокировок в одной транзакции (см. https://www.safaribooksonline.com/library/view/pro-sql-server/9781484219645/A313962_2_En_23_Chapter.html#Par13).
        
Поиск и устранение неисправностей.
    График взаимоблокировки (deadlock graph), предоставляет информацию о взаимоблокировке в формате XML.
    
    Способы получения графика взаимоблокировки:
        - Флаг трасировки T1222 сохраняет информацию о блокировке в журнале ошибок SQL Server.
        - Расширенное событие xml_deadlock_report.
          Сеанс расширенного события system_health захватывает событие xml_deadlock_report.
        - SQL Server Profiler Locks:Deadlock Graph.
        - Cоздать уведомление о событии, которое срабатывает при возникновении взаимоблокировки.
        
Уменьшение взимоблокировок.
    Оптимизация запросов. Сканирование, являются наиболее распространенными причинами взаимоблокировок. 
    Корректные индексы не только улучшают производительность запросов, но также уменьшают количество строк, 
    которые необходимо прочитать, и блокировки, которые необходимо приобрести, что уменьшает вероятность столкновения с другими сеансами.

    Держите блокировки как можно короче. Сделайте транзакции короткими и попытайтесь обновить данные как можно ближе к концу транзакции, 
    чтобы уменьшить вероятность столкновения блокировки.

    Используйте самый низкий уровень изоляции транзакций, который обеспечивает необходимую согласованность данных.
    Это уменьшает время, в течение которого хранятся общие (S) блокировки.       

    Избегайте обновления строки несколько раз в рамках одной транзакции, когда задействованы несколько индексов. 
    SQL Server не размещает исключительные (X) блокировки в некластеризованных строках индекса, когда столбцы индекса не обновляются.
    Другие сеансы могут помещать туда несовместимые блокировки и блокировать последующие обновления, что приведет к взаимоблокировкам.

    Используйте логику повтора. Оберните критический код в TRY..CATCH и повторите действие, если происходит взаимоблокировка. 
    Номер ошибки для исключения, вызванного тупиком, равен 1205.