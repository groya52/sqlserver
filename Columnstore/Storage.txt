Каждый столбец данных в хранилище на основе столбцов хранится отдельно в наборе структур, называемых группами строк. 
Каждая группа строк хранит данные примерно до одного миллиона или, точнее, 2^20 = 1 048 576 строк.

SQL Server пытается заполнить группы строк полностью во время создания индекса, 
оставив группу последних рядов частично заполненной.

Может быть более одной частично заполненной группы строк, 
когда несколько потоков создают индексы столбцов, используя параллельные планы выполнения.
Каждый поток будет работать со своим собственным подмножеством данных, создавая отдельные группы строк. 
В случае секционированных таблиц каждый раздел таблицы имеет свой собственный набор групп строк.

После создания групп строк SQL Server объединяет все данные столбцов в каждой группе строк, кодирует и сжимает эти группы.
Строки в группе строк могут быть перегруппированы, если это помогает достичь лучшей степени сжатия.

Данные столбцов в группе строк называются сегментами. 
SQL Server загружает весь сегмент в память, когда ему нужно получить доступ к данным столбцов.
SQL Server также сохраняет информацию о данных, хранящихся в каждом сегменте в метаданных сегмента, 
например минимальные и максимальные значения, и может пропускать сегменты, у которых нет требуемых данных.

Процесс создания индекса (см. рис. Создание columnstore индекса.jpg).

    Во время кодирования SQL Server заменяет все значения в данных на 64-битные целые числа, 
    используя один из двух алгоритмов кодирования.

        Первый алгоритм, называемый кодировка словаря (dictionary encoding) (см. рис. Кодирование на основе значений.jpg), хранит различные значения из данных в отдельной структуре, называемой словарем (dictionary).
        Каждое значение в словаре имеет уникальный идентификатор (ID). SQL Server заменяет фактическое значение в данных идентификатором (ID) из словаря.
        
        SQL Server создает один глобальный словарь (global dictionary), который является общим для всех сегментов, принадлежащих одному и тому же разделу индекса.
        Кроме того, SQL Server может создавать локальные словари (local dictionary) для отдельных сегментов, используя значения, отсутствующие в глобальном словаре.
        
        Второй тип кодирования, называемый кодированием на основе значений (value-based encoding), в основном используется для числовых и целочисленных типов данных, которые не имеют достаточных дублированных значений.
        При этом условии кодировка словаря неэффективна. Цель кодирования на основе значений - преобразовать целочисленные и числовые значения в меньший диапазон 64-битных целых чисел.
        
            Этот процесс состоит из следующих двух шагов (см. рис. Кодирование на основе значений.jpg).
                
                На первом этапе числовые типы данных преобразуются в целые числа, используя минимальный положительный показатель (такой показатель называется величиной), который допускает это преобразование.
                Целью этого процесса является преобразование всех числовых значений в целые числа.
                
                Для целочисленных типов данных SQL Server выбирает наименьший отрицательный показатель. 
                Цель такой операции - уменьшить интервал между минимальным и максимальным значениями, хранящимися в сегменте.
                
                На втором этапе SQL Server выбирает базовое значение (base value), которое является минимальным значением в сегменте, и вычитает его из всех других значений.
        
    После кодирования SQL Server сжимает данные и сохраняет их как блок распределения больших объектов (LOB allocation unit).
    
    Данные в индексах columnstore сильно сжаты и могут обеспечить значительную экономию пространства. 
    
    SQL Server 2014 вводит еще один вариант сжатия, называемый архивное сжатие (archival compression).
    Он использует библиотеку сжатия Xpress 8, которая является внутренней реализацией Microsoft алгоритма LZ77. 
    Это сжатие работает напрямую с двоичными данными без каких-либо знаний о базовых структурах данных SQL Server.
    
    Его можно применять ко всему индексу или отдельным разделам, 
    указав свойство индекса столбца DATA_COMPRESSION = COLUMNSTORE_ARCHIVE, 
    и еще больше сократить пространство для хранения.
    
    Архивное сжатие работает прозрачно с другими функциями SQL Server. 
    Данные столбцов сжимаются в то время, когда они сохраняются на диск и распаковываются, 
    прежде чем они будут загружены в память.
    
    Архивирование сжатия приводит к дополнительным нагрузкам на процессор на этапах сжатия и декомпрессии.
    
    Архивированое сжатия является отличным выбором для статических, редко доступных данных.
    Вы можете рассмотреть возможность применения архивного сжатия на разделах, 
    которые хранят старые данные и извлекают выгоду из экономии дискового пространства, которую он достигает.
    
Кластерные индексы columnstore используют тот же формат хранения, 
что и некластеризованные индексы columnstore, сохраняя данные столбцов в группах строк.

Они имеют дополнительные элементы, которые поддерживают модификации данных (используют формат B-tree для хранения данных) (см. рис. Структура кластерного индекса columnstore.jpg):
    - Delete Bitmap. 
        Указывает, какие строки были удалены из таблицы.
    - Delta Store.
        Включает в себя вновь вставленные строки.
    
Каждый раздел может иметь один delete bitmap и несколько delta store.
Эта структура делает каждый раздел автономным и независимым от других разделов, 
что позволяет выполнять переключение разделов на таблицы с кластеризованными индексами columnstore.

Delete bitmap и delta store создаются по требованию (например, delete bitmap не будет создана, если строки в группах строк не были удалены).

Когда удаляется строка, которая хранится в группе строк (не в delta store), SQL Server добавляет информацию об удаленной строке в delete bitmap.
Ничего не происходит с исходной строкой, она по-прежнему сохраняется в группе строк. 
SQL Server проверяет delete bitmap во время выполнения запроса и исключает удаленные строки из обработки.

Обновление строки, которая хранится в группе строк, не изменяет данные строки.
Такое обновление запускает удаление строки, которая, по сути, 
добавляет информацию об измененной строке в delete bitmap и вставляет новую версию строки в delta store. 
Однако любые изменения данных строк в delta store выполняются так же, 
как и в обычных индексах B-tree, путем обновления и удаления существующих строк.

Каждый delta store может находиться в открытом или закрытом состоянии. 
Открытые delta store принимают новые строки и позволяют изменять и удалять данные.

SQL Server закрывает delta store, когда он достигает 1 048 576 строк, 
что является максимальным количеством строк, которые могут быть сохранены в группе строк. 

Другой процесс SQL Server, называемый tuple mover, 
запускается каждые пять минут и конвертирует закрытые delta store в группы строк, 
которые хранят данные в формате хранения на основе столбцов.
Можно принудительно преобразовать закрытые delta store в группы строк, 
перестроив индекс командой ALTER INDEX REORGANIZE.

Tuple mover однопоточный процесс, который работает в фоновом режиме, сохраняя системные ресурсы.
REORGANIZE индекса выполняется параллельно с использованием нескольких потоков. 
Такой подход может значительно уменьшить время преобразования за счет дополнительной загрузки ЦП и использования памяти.

Tuple mover и REORGANIZE индекса не позволяют другим сеансам вставлять новые данные в таблицу.
Новые данные будут вставлены в другие открытые delta store. 
Удаление и модификация данных будут заблокированы на время выполнения операции.

Можно отключить процесс tuple mover флагом трассировки T634.

Можно просмотреть состояние групп строк и delta store с помощью представления sys.column_store_row_groups.

SQL Server загружает данные столбцов в память на основе каждого сегмента, 
сегменты представляют данные для одного столбца в группе строк.
Более эффективно загружать и обрабатывать меньшее количество полностью заполненных сегментов по сравнению с большим количеством частично заполненных сегментов. 
Чрезмерное количество частично заполненных групп строк отрицательно влияет на производительность SQL Server.

Если производится объемная загрузка данных в таблицу с кластерным индексом columnstore, 
можно получить наилучшие результаты, выбрав размер партии, который делится на 1 048 576 строк.
Это гарантирует, что каждая партия производит одну или несколько полностью заполненных групп строк, 
уменьшает общее количество групп строк в таблице и улучшает производительность запросов.
Однако не превышайте это число, потому что пакет не помещается в одну группу строк.

SQL Server хранит сегменты столбцов в блоках распределения LOB_DATA. 
Delta store и delete bitmap используют распределение IN_ROW_DATA.
    
CSILOCATOR - внутренний уникальный идентификатор строки в delta store.

В SQL Server 2014 страницы delta store сжимаются, сжатие может увеличить размер строки, 
а в некоторых случаях - запретить создание индексов columnstore с очень большим количеством столбцов.
Сжатие страницы для delta store удалено в SQL Server 2016 для решения этой проблемы.

При больших delta store, накладные расходы на выполнение запроса больше в SQL Server 2016, 
где delta store не использует сжатие страницы и требует больше операций ввода-вывода для сканирования.
 
Страницы delete bitmap, используют сжатие страниц в SQL Server 2014 и 2016.
 
Обслуживание индекса.
    ALTER INDEX REBUILD 
        REBUILD заставляет SQL Server удалять удаленные строки физически из индекса и объединять данные delta store и групп строк. 
        Все сегменты столбцов воссозданы с заполненны группами строк.
        
        Процесс перестройки индекса очень ресурсоемкий. 
        Более того, он содержит блокировку схемы (Sch-M) в таблице, тем самым предотвращая доступ другим сеансам.
        
        Перестройка индекса columnstore является автономной операцией, 
        поэтому вы не можете использовать предложение ONLINE = ON.
        
        Подобно индексам B-tree, вы можете уменьшить накладные расходы на перестройку индекса, 
        используя секционирование таблиц и индексов.
        
        Вы можете перестроить индексы на основе разделов и сделать это только для разделов, 
        содержащих изменчивые данные.
    
    Индексы columnstore поддерживает процесс REORGANIZE онлайн-индекса, 
    который вы можете активировать с помощью команды ALTER INDEX REORGANIZE.
    
    В SQL Server 2014 единственным действием, выполняемым реорганизацией индекса, 
    по умолчанию является сжатие и перемещение данных из закрытых delta store в группы строк.
    
    Delete bitmap и открытые delta store остаются нетронутыми.

    В SQL Server 2016 реорганизация индекса также выполняет дополнительную дефрагментацию следующим образом:
        - Он удаляет удаленные строки из групп строк, 
          которые имеют 10 или более процентов строк, логически удаленных.
        - Он объединяет замкнутые группы строк вместе, 
          сохраняя общее количество строк меньше или равно 1 024 576.
        
    Процессы вставки не блокируются в течение этого времени REORGANIZE.    