Изначальная компиляция преобразует любую логику манипулирования строкой и доступом в C код, который скомпилирован в DLL и загружается в память процесса SQL Server.

DLL не сохраняются в резервной копии базы данных. 
SQL Server пересоздает связанные оптимизированной для памяти таблицей библиотеки DLL при запуске базы и изначально скомпилированные хранимые процедурами во время первого вызова.
Это может добавить накладные расходы при запуске базы данных и изменить планы выполнения изначально скомпилированных хранимых процедур после перезапуска базы данных.

Библиотеки DLL и все другие родственные файлы, связанные с компиляцией, помещаются в подпапку XTP в основном каталоге данных SQL Server. 
Файлы группируются по каждой базе данных, создавая еще один уровень подпапок.
Имена файлов начинаются с префикса xtp_, за которым следуют символ p (хранимая процедура) или t (таблица). Две последние части имени включают идентификатор базы данных и объекта.

Расширения файлов определяют тип файла, такие как:
    *.xml хранят XML-представление структуры MAT.
    *.c исходный файл, сгенерированный генератором кода C.
    *.obj объектные файлы, сгенерированные компилятором C.
    *.pdb файлы символов, созданные компилятором C.
    *.out файлы журналов из компилятора C.
    *.dll изначально скомпилированные DLL-файлы, сгенерированные C-компоновщиком. Эти файлы загружаются в память SQL Server и используются встроенным OLTP-модулем.

В SQL Server 2016 есть три типа изначально скомпилированных модулей, включая хранимые процедуры, скалярные и табличные функции, определяемые пользователем, и триггеры (доступны только в таблицах с оптимизацией для памяти, AFTER).
Только хранимые процедуры были доступны в SQL Server 2014.
    
Структура изначально скомпилированной процедуры:
    CREATE PROC procedure_name
    ( 
        / * Параметры * / 
        @Param1 int NOT NULL = 1 
       ,@Param2 int
    ) 
    WITH
        NATIVE_COMPILATION
       ,SCHEMABINDING
       ,EXECUTE AS OWNER
    AS
    BEGIN ATOMIC WITH
    (
        TRANSACTION ISOLATION LEVEL = SNAPSHOT | REPEATABLE READ | SERIALIZABLE
       ,LANGUAGE = N'English'
       ,DELAYED_DURABILITY = OFF
       ,DATEFIRST = 7
       ,DATEFORMAT = 'MDY'
    )
        /* Stored Procedure Body */
    END;
    
    Параметры определяются в изначально скомпилированных хранимых процедур так же, как и с процедурами T-SQL. 
    Изначально скомпилированные хранимые процедуры позволяют указать, нужны ли параметры во время вызова, используя конструкцию NOT NULL в определении. SQL Server вызывает ошибку, если не были указали значения во время вызова.
    
    Изначально скомпилированные хранимые процедуры могут получать доступ только к таблицам оптимизированным для памяти.
    
    Изначально скомпилированные хранимые процедуры, компилируются во время создания. Они никогда не перекомпилируются, только после перезапуски SQL Server (перекомпиляция происходит во время первого вызова хранимой процедуры).
    
    SQL Server не оценивает параметры во время компиляции, оптимизируя утверждения для значений UNKNOWN.
    
    Изначально скомпилированные хранимые процедуры не поддерживают Hash Match и Merge Join, которые могут превосходить Nested Loops на больших и несортированных входах.
    
    Для обеспечения производительности есть две рекомендации, связанные с параметрами:
        - убедитесь, что тип данных параметра, передаваемого процедуре, имеет тип, объявленный в процедуре;
        - не используйте именованные параметры при вызове процедуры.
    
    Существует множество ограничений при использовании изначально скомпилированной хранимой процедуры см. https://docs.microsoft.com/ru-ru/sql/relational-databases/in-memory-oltp/transact-sql-constructs-not-supported-by-in-memory-oltp.
    
Оптимизированный для памяти табличный тип.
     Для создания переменной таблицы с оптимизацией памяти требуется два шага:
        1. Создать тип, используя предложение MEMORY_OPTIMIZED = ON, которое, как и любая другая оптимизированная память, требует индекса. 
        2. Объявить переменную таблицы с оптимизацией памяти с использованием типа.

    CREATE TYPE type_name AS TABLE 
    ( 
        ...
    ) WITH (MEMORY_OPTIMIZED = ON); 

    Оптимизированные для памяти табличные переменные живут только в памяти и не используют tempdb.
    
    Можно определять индексы для табличных переменных оптимизированных для памяти. Те же ограничения по статистике по-прежнему применяются.
    
    Перекомпиляция на уровне инструкций не позволяет получать количество строк табличных переменных оптимизированных для памяти. Он всегда оценивает, что табличные переменные оптимизированные для памяти имеют только одну строку.
    
    Можно передавать табличные переменные оптимизированной для памяти таблицы, в виде табличных параметров для изначально скомпилированных и регулярных процедур T-SQL.
    