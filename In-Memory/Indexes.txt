-- Проверить
Ограничения:
    Таблицы с оптимизацией памяти не поддерживают уникальные или отфильтрованные индексы.
    Все ключевые столбцы индексов должны быть объявлены с NOT NULL .
    Поскольку все столбцы таблицы с оптимизированной памятью неотъемлемо покрываются, предложение INCLUDE не допускается.
    Столбцы символов в ключе индекса должны использовать сортировку BIN2 .
    Хэш-индекс не имеет порядка, поэтому индекс не может указывать ключевые слова ASC / DESC .
    Таблицы с оптимизацией памяти не поддерживают auto_update_statistics - вы должны пересчитывать статистику вручную после того, как таблица была заполнена данными, а именно:
--

Хеш индексы
    Хеш индексы являются, хеш-таблицами с bucket'ми, реализованными как массив предопределенного размера.
    Каждый bucket содержит указатель на строку данных. SQL Server применяет хеш-функцию к значениям ключа индекса, а результат функции определяет, к какому bucket'у принадлежит строка.
    Все строки, имеющие одно и то же значение хеша, принадлежат одному и тому же bucket'у и связаны между собой цепочкой указателей.

    Количество bucket'ов является критическим элементом в производительности хеш-индекса. 
    В хеш-таблице будут возникать столкновения, когда количество bucket'ов не будет достаточно большим, и SQL Server должен хранить разные хеши вместе в одних и тех же bucket'ах. 
    Эти столкновения приводят к более длинным цепочкам строк, что требует, чтобы SQL Server сканировал больше строк во время обработки запроса.
    
    Недооценка или переоценка количества bucket'ов может ухудшить производительность системы.
    Каждый bucket использует 8 байтов для хранения указателя памяти, а большое количество неиспользуемых bucket'ов - это трата системной памяти. 
    SQL Server должен сканировать все bucket'ы в индексе, когда он выполняет сканирование индекса и дополнительные bucket'ы добавляют накладные расходы в процесс.
    
    В идеальной ситуации необходимо иметь количество bucket'ов, превышающих мощность (количество уникальных ключей) индекса. 
    Не рекомендуется создавать индекс, основанный на текущей мощности данных, если ожидается, что система будет обрабатывать гораздо больше данных в будущем.

    SQL Server 2016 позволяет использовать оператор ALTER TABLE для изменения количества bucket'ов, но это все еще является существенным изменением структуры таблицы, 
    и это операция блокировки, которую вы можете выполнять только во время окна обслуживания.
    
    Столбцы большим количеством дублированных значений являются плохими кандидатами для хеш индексов. Те же самые значения данных генерируют один и тот же хеш, и поэтому строки будут связаны длинными цепочками строк.

    Можете проанализировать вывод представления sys.dm_db_xpt_hash_index_stats, чтобы определить, достаточно ли количества bucket'ов в индексе. 
    Если количество пустых bucket'ов составляет менее 10% от общего количества bucket'ов в индексе, количество bucket'ов, вероятно, будет слишком низким. 
    В идеале, 33% bucket'ов в индексе должны быть пустыми.

    Хеш индексы эффективны только в случае поиска равенства по точкам, что позволяет SQL Server вычислять соответствующее хеш-значение ключа индекса и находить bucket, который ссылается на нужную цепочку строк.
    
    В случае составных хеш-индексов SQL Server вычисляет хэш-значение для комбинированного значения всех ключевых столбцов. Поэтому запрос должен иметь предикаты равенства для всех ключевых столбцов, чтобы индекс был полезным.
    
    SQL Server создает статистику по индексу, но в SQL Server 2014 статистика автоматически не обновляется. 
    Это необходимо учитывать при разработке стратегии обслуживания статистики в системе. Вы должны обновить статистику после того, как данные будут загружены в таблицу.
    Если данные в таблице нестабильны, необходимо обновлять статистику на регулярной основе.
    
    В SQL Server 2016 статистика автоматически обновляется. Теперь вы можете также указать образец, когда вручную обновляете статистику.
    
    Обновленная статистика не сразу приносит пользу изначально скомпилированным модулям так же, т.е. обновление статистики, как вручную, так и автоматически, не инициирует новую оптимизацию для изначально скомпилированных модулей.
    Необходимо вручную перекомпилировать их, например, используя хранимую процедуру системы sp_recompile.
    
    В SQL Server 2014 необходимо обновлять статистику вручную с помощью инструкции UPDATE STATISTICS или процедуры sp_updatestats на регулярной основе.
    SQL Server 2014 всегда выполняет полную проверку (FULLSCAN) при обновлении статистики. Необходимо указать параметр NORECOMPUTE при запуске инструкций CREATE STATISTICS или UPDATE STATISTICS.
          
Некластеризованные индексы
    Некластеризованные индексы помогают искать данные на основе диапазона значений.
    
    Нельзя индексировать текстовые данные, если столбец не использует двоичную сортировку BIN2.
    
    Некластеризованные индексы являются однонаправленными, и SQL Server не может сканировать индексные ключи в порядке, противоположном тому, как они были отсортированы.
    
    Cтатистика создается во время создания индекса, но не обновляются автоматически.
    
    Bw-Tree (см. Структура некластеризованного индекса.jpg)
        Bw-Tree страницы не имеют фиксированного размера и неизменяемы после их создания. Максимальный размер страницы составляет 8 КБ.
        
        Строки из уровня листа (Leaf Level) некластеризованного индекса содержат указатели на цепочки строк данных (Data Rows) с одинаковыми значениями ключа.
        
        Корневые (Root) и промежуточные уровни (Intermediate level) в некластеризованных индексах называются внутренними страницами.
        
        Внутренние страницы указывают на следующий уровень в индексе, используя логический идентификатор страницы (PID), который является позицией (смещением) в отдельной структуре, подобной массиву, называемой таблицей сопоставления (Mapping Table).
        Каждый элемент таблицы сопоставления содержит указатель на фактическую страницу индекса.
        
        Каждая строка индекса из внутренней страницы сохраняет наивысшее значение ключа на странице следующего уровня и PID.
        Каждая страница знает PID следующей страницы на одном уровне и не знает PID предыдущей страницы.
        Несмотря на то, что он отображается как указатель (стрелка) (Reference is done throught thе mapping table) (см. Структура некластеризованного индекса.jpg), эта ссылка выполняется через таблицу сопоставления, аналогичную ссылкам на страницы на следующем уровне.
        
    Некластеризованные индексы в памяти хранят одну строку индекса (указатель) в цепочке строк, которая включает в себя все строки данных, которые имеют одинаковое значение ключа. 
    В индекс сохраняется только одна строка индекса (указатель) на каждое значение ключа.
    
    Внутренние и листовые страницы некластеризованных индексов состоят из двух областей: заголовок и данные (см. https://www.safaribooksonline.com/library/view/expert-sql-server/9781484211366/9781484211373_Ch05.xhtml#Sec6).
    
    Страницы в некластеризованных индексах неизменяемы после их создания. 
    Когда необходимо обновить страницу, cоздается новая версия страницы, и заменяет указатель страницы в таблице сопоставления, что позволяет избежать изменения внутренних страниц, ссылающихся на старую (устаревшую) страницу.
    
    Когда необходимо изменить индексную страницу на уровне листа, создается одна или две дельта записи, которые представляют изменения (см. Дельта записи и страница уровня листа некластиризованного индекса.jpg). 
    Операции INSERT и DELETE генерируют одну дельта записи вставки или удаления, операция UPDATE генерирует две дельта записи, удаляя старые и вставляя новые значения.
    Дельта записи создают цепочку указателей памяти с последним указателем на фактическую страницу индекса. Также заменяется указатель в таблице сопоставления адресом первой дельта записи в цепочке.
    
    Записи дельта, являются страницами с одной записью данных индекса. Структура страниц данных дельты аналогична структуре внутренних и листовых страниц. 
    Страницы данных дельта хранят код операции (вставка или удаление), ключевое значение и указатель на первую строку данных в цепочке строк (см. Страница индекса листового уровня с дельта записью вставки.jpg).
    
    SQL Server должен проходить и анализировать все дельта записи при доступе к странице индекса. Длинная цепочка дельта записей влияет на производительность. 
    SQL Server объединяет дельта записи и перестраивает индексную страницу, создавая новую. Созданная страница имеет тот же PID и заменяет старую страницу, помеченную для сбора мусора.
    Замена страницы выполняется путем изменения указателя в таблице сопоставления. SQL Server не нужно изменять внутренние страницы, потому что они используют таблицу сопоставления для ссылки на страницы уровня листа.
    
    Процесс перестройки запускается в момент создания новой дельта записи для страниц, на которых уже есть 16 дельта записей в цепочке. Действие, которая запускает перестройку, включается во вновь созданную страницу.
    
    Два других процесса могут создавать новые или удалять существующие индексные страницы в дополнение к консолидации дельта-записей. 
    Разбиение страницы, происходит, когда на странице недостаточно свободного места для размещения новой строки данных. 
    Слияние страниц, происходит, когда операция удаления оставляет индексную страницу менее 10% от максимального размера страницы, которая сейчас составляет 8 КБ, или когда индексная страница содержит только одну строку.