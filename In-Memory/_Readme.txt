Настройка базы данных.
    Создание новой базы данных, которая включает файловую группу для хранения объектов данных In-Memory:
        CREATE DATABASE database_name
        ON 
            PRIMARY 
            (
                NAME = logical_file_name
               ,FILENAME = 'os_file_name'
            )
           ,FILEGROUP filegroup_name CONTAINS MEMORY_OPTIMIZED_DATA 
            (
                NAME = logical_file_name
               ,FILENAME = 'os_file_name'
            )
        LOG ON
        (
            NAME = logical_file_name
           ,FILENAME = 'os_file_name'
        )
        COLLATE LATIN1_GENERAL_BIN2;

    Создание новой файловой группы в существующей базе данных:
        ALTER DATABASE database_name ADD FILEGROUP filegroup_name CONTAINS MEMORY_OPTIMIZED_DATA;
        
        ALTER DATABASE database_name ADD FILE 
        (
            NAME = logical_file_name
           ,FILENAME = 'os_file_name'
        )
        TO FILEGROUP filegroup_name;
    
    База данных может иметь только одну файловую группу, которая содержит данные с оптимизацией памяти. 
    Эта файловая группа не может быть удалена из базы данных (единственный способ удалить эту файловую группу - удалить базу данных).
    
    Контейнеры файловой группы будут содержать два типа файлов: файлы данных и разностные файлы. 
    Каждый файл данных соединен с разностным файлом, и вместе эта пара называется парой файлов контрольных точек (CFP).
    
    Если сервер имеет до 16 ГБ системной пямяти тогда размер файла данных составляет 16 МБ, а разностного файла - 1 МБ.
    Если сервер имеет более 16 ГБ системной пямяти тогда размер файла данных составляет 128 МБ, а разностного файла - 16 МБ.
    Строки, подверженные влиянию одной транзакции, должны быть в одном CFP, поэтому файл данных может превышать начальный размер.

    Создание таблицы:
        SQL Server предоставляет способ помочь вам найти и оценить несовместимость при переносе таблиц с помощью инструмента Memory Optimization Advisor.
        SQL Server предоставляет аналогичный инструмент для хранимых процедур и другого кода, называемого Stored Procedure Native Compilation Advisor.
    
        CREATE TABLE table_name 
        (
            ID int PRIMARY KEY NONCLUSTERED HASH WITH (BUCKET_COUNT = bucket_count)
            ID int PRIMARY KEY NONCLUSTERED
            ...
        ) WITH (MEMORY_OPTIMIZED = ON, DURABILITY = SCHEMA_AND_DATA);
    
        Существует два уровня долговечности для таблицы с оптимизированной памятью: 
            SCHEMA_ONLY
                Транзакции данных не будут помещены в журнал транзакций, и они не будут сохраняться на жестком диске.
            SCHEMA_AND_DATA
                Транзакции данных помещаются в журнал транзакций, и они будут сохраняться на жестком диске.
                
    Каждая таблица оптимизированная для памяти требует по крайней мере одного индекса, а также требует первичного ключа.
    
    В SQL Server 2014 невозможно было добавить или удалить столбцы или индексы (что означает, что они должны быть включены как часть инструкции CREATE TABLE) или изменить любые его свойства.
    В SQL Server 2016 можно использовать инструкцию ALTER TABLE с оптимизированными для памяти таблицами, чтобы изменить большинство свойств таблицы.
    
    Каждая таблица должна содержать не менее одного и не более восьми индексов.
    Существует два типа индексов для таблиц оптимизированных для памяти (см. Indexes.txt): некластеризованный индекс и хеш индекс.
    
    ALTER TABLE теперь доступен для изменения большинства свойств таблицы, включая добавление и удаление столбцов, добавление и удаление индексов или изменение значения для BUCKET_COUNT в хэш-индексе. 
    CREATE INDEX и DROP INDEX не допускаются с оптимизированными для памяти таблицами.
    
Каждая строка в таблице оптимизированной для памяти имеет два значения, называемые BeginTs и EndTs, которые определяют время жизни строки. 
Экземпляр SQL Server поддерживает значение временной метки глобальной транзакции, которое автоматически увеличивается при совершении транзакции и является уникальным для каждой совершенной транзакции. 
BeginTs хранит глобальную метку транзакции, в которую вставлена ​​строка, а EndTs хранит временную метку транзакции, которая удалила строку.
Специальное значение Infinity используется как EndTs для строк, которые не были удалены.

Строки для таблиц оптимизированных для памяти никогда не обновляются. 
Операция обновления создает новую версию строки с новой отметкой Global Transaction Timestamp, установленной как BeginTs и отмечает, что старая версия строки удалена путем заполнения EndTs временная метка с одинаковым значением.

Транзакция может видеть строку только тогда, когда ее временная метка транзакции находится между отметками времени BeginTs и EndTs строки.

Формат строк данных в оптимизированных по памяти таблицах полностью отличается от таблиц на диске (см. Структура строки данных в таблицах оптимизированных для памяти).
    StmtId
        Ссылается на инструкцию, которой вставлена ​​эта строка. Каждый оператор транзакции имеет уникальное 4-байтовое значение StmtId, которое работает как технология защиты от Хэллоуина и позволяет оператору пропускать только что вставленные им строки.
        Помогает избежать проблемы Хэллоуина в оптимизированных по памяти таблицах. Инструкция проверяют StmtId строк и пропускают те, которые они только что вставили.
    IdxLinkCount
        Указывает, сколько индексов (указателей) ссылается на строку. SQL Server использует его для обнаружения строк, которые могут быть освобождены процессом сбора мусора.
    Index Pointer Array
        Каждая таблица оптимизированная для памяти должна иметь как минимум один индекс для связывания строк данных вместе. 
        В лучшем случае вы можете определить восемь индексов для таблицы оптимизированной для памяти, включая ограничение первичного ключа.
    Pay Load
        Фактические данные строки хранятся в данном разделе. Формат полезной нагрузки может варьироваться в зависимости от схемы таблицы. 
        SQL Server работает с полезной нагрузкой через DLL, которая сгенерирована и скомпилирована для таблицы.

SQL Server создает и компилирует отдельные библиотеки DLL для каждой таблицы оптимизированной для памяти в системе. 
Эти DLL-файлы загружаются в процесс SQL Server, и они несут ответственность за доступ к данным и их обработку в разделе Pay Load в строке. 
In-Memory OLTP модуль является общим и ничего не знает о базовых структурах строк, весь доступ к данным осуществляется через эти DLL.
        
Обработка транзакций.
    In-Memory OLTP поддерживает три уровня изоляции транзакций: SNAPSHOT, REPEATABLE READ и SERIALIZABLE.
    
    Вместо того, чтобы блокировать или быть заблокированным от других сеансов, In-Memory OLTP проверяет согласованность данных во время COMMIT и выдает исключение и откатывает транзакцию, если правила были нарушены.
    
    SNAPSHOT 
        Любые изменения, сделанные другими сеансами, невидимы для транзакции. Уровень изоляции SNAPSHOT всегда работает со снимком данных по состоянию на момент начала транзакции. 
        Единственная проверка на момент фиксации - проверка нарушений первичного ключа, которая называется проверкой моментальных снимков.
      
    REPEATABLE READ
        In-Memory OLTP проверяет, что строки, которые были прочитаны транзакцией, не были изменены или удалены другими транзакциями. 
        REPEATABLE READ транзакция не сможет совершиться, если это имело место. Это действие называется повторной проверкой чтения.
        
        Другие сеансы могут модифицировать данные, которые были прочитаны активной транзакцией REPEATABLE READ.
        Это приводит к прерыванию транзакции во время COMMIT, когда сбой повторной проверки чтения не удался.
    
    SERIALIZABLE
        SQL Server выполняет повторную проверку чтения, а также проверяет фантомные строки, которые, возможно, были добавлены другими сеансами. Этот процесс называется сериализуемой валидацией.
        
        Уровень изоляции SERIALIZABLE не позволяет сеансу совершить транзакцию, когда другой сеанс вставил новую строку и нарушил сериализуемую проверку.
        
    Уровень изоляции     Грязные чтения     Неповторяющиеся чтения      Фантомные чтения
    REPEATABLE READ      НЕТ                НЕТ                         НЕТ
    SERIALIZABLE         НЕТ                НЕТ                         НЕТ  
    SNAPSHOT             НЕТ                НЕТ                         НЕТ
    
    Конфликты запись/запись работают одинаково независимо от уровня изоляции транзакций в In-Memory OLTP.
    SQL Server не позволяет транзакции изменять строку, которая была изменена другими незафиксированными транзакциями.
    
    Когда подсказка опущена, оператор работает на уровне изоляции SNAPSHOT.
    
    Транзакция между контейнерами.
        Транзакция выполняется между двумя контейнерами по управлению транзакциями (один — для дисковых таблиц, а другой — для таблиц, оптимизированных для памяти).
        
        Транзакция между контейнерами, состоят из двух внутренних транзакций: один для дисковых таблиц и другой таблиц оптимизированных для памяти.
        
        Возможные комбинации уровней изоляции транзакций между контейнерами:
        
            Уровни изоляции дисковых таблиц                               Уровни изоляции таблиц, оптимизированных для памяти
            READ UNCOMMITTED, READ COMMITTED, READ COMMITTED SNAPSHOT     SNAPSHOT, REPEATABLE READ, SERIALIZABLE
    
            REPEATABLE READ, SERIALIZABLE                                 SNAPSHOT
    
            SNAPSHOT                                                      Not supported.
            
        Рекомендуется использовать комбинацию READ COMMITTED/SNAPSHOT в транзакциях между контейнерами во время обычной рабочей нагрузки.
        Эта комбинация обеспечивает минимальную блокировку и минимальные затраты на предварительную фиксацию и должна быть приемлемой в большом количестве случаев использования.
        Другие комбинации более уместны во время миграции данных, когда важно избегать неповторяющихся и фантомных чтений.
        
    Опция базы данных MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT (по умолчанию отключена), позволяет опустить подсказку уровня изоляции в не автоматических транзакциях, продвигающих их на уровень изоляции SNAPSHOT, как и с автоматическими транзакциями.
    
    Срок службы транзакции, зависимости фиксации см. https://www.safaribooksonline.com/library/view/expert-sql-server/9781484211366/9781484211373_Ch08.xhtml#Sec4.
        Можно отслеживать фиксацию зависимостей, используя расширенные события dependency_acquiredtx_event и waiting_for_dependenciestx_event.
        
    Самая старая контрольная временная дата транзакций контролируется, когда истекшие строки могут быть удалены из цепочек индексов и освобождены. 
    Долгосрочные и отложенные транзакции могут отложить сборку мусора и привести к ситуации, когда в системе заканчивается память из-за чрезмерного количества просроченных строк.
     
SQL Server 2014 не поддерживает параллельные планы выполнения для операторов, которые получают доступ к таблицам с оптимизацией памяти.

Сборка мусора (см.ht tps://www.safaribooksonline.com/library/view/expert-sql-server/9781484211366/9781484211373_Ch09.xhtml).