Когда строки удаляются из кучи, страницы, связанные с этими строками, 
не удаляются из кучи (раздувание внутри кучи).

Когда данные удаляются из кучи, пространство, в котором ранее хранятся данные, 
становится доступным для будущих вставок в таблицу (после того, как отработает ghost cleanup).

Идентификатор строки кучи (RID), имеет длину 8 байт.

При создании кластеризованного индекса все существующие некластеризованные индексы таблицы перестраиваются.

Индексный ключ рекомендуется быть уникальным, если это не так, будет добавлен уникальный идентификатор 4 байта.
Уникальный идентификатор занимают место только при необходимости, 
и он нужны только тогда, когда значение ключа/составного ключа не уникально.

Если столбцы в кластерном ключе не уникальны, SQL Server добавит скрытый столбец uniquifier в строку. 
Uniquifier - это 4-байтовое числовое значение, которое добавляется для обеспечения уникальности. 
Размер uniquifier не считается частью максимально допустимого размера индекса.

Каждая таблица может содержать до 999 некластеризованных индексов.

Для индексированных представлений некластеризованные индексы могут создаваться только в случае, 
если уже определен уникальный кластеризованный индекс.

Если в качестве модели восстановления базы данных используется модель с неполным протоколированием или простая модель,
операция создания индекса может выполняться с минимальным протоколированием.

При создании кластерного индекса в существующей таблице с кучей, необходимо убедитьтся, 
что достаточно свободного места для второй копии данных.
Пока сборка индекса не будет завершена, обе копии данных будут существовать.

Если проблема с вставкой последней страницы (last page insert contention) является серьезным узким местом в вашем приложении, 
вам определенно стоит подумать об использовании оптимизированных для памяти таблиц.

Синтаксис (см. https://docs.microsoft.com/ru-ru/sql/t-sql/statements/create-index-transact-sql).

    CREATE [ UNIQUE ] [ CLUSTERED | NONCLUSTERED ] INDEX index_name
        ON <object> ( column [ ASC | DESC ] [ ,...n ] )   
        [ INCLUDE ( column_name [ ,...n ] ) ]  
        [ WHERE <filter_predicate> ]  
        [ WITH ( <relational_index_option> [ ,...n ] ) ]  
        [ ON { partition_scheme_name ( column_name )   
            | filegroup_name   
            | default   
            }  
        ]  
        [ FILESTREAM_ON { filestream_filegroup_name | partition_scheme_name | "NULL" } ]
    [ ; ]

    column
        < SQL Server 2012
            До 16 столбцов можно объединить в один составной ключ индекса.
            Максимально допустимый размер значений составного индекса является 900 байт.
        >= SQL Server 2012
            До 32 столбцов можно объединить в один составной ключ индекса. 
            Максимально допустимый размер значений составного индекса является 900 байт для кластеризованного индекса или 1700 байт для некластеризованного индекса.
    
        Столбцы, имеющие типы данных больших объектов ntext, text, varchar(max), nvarchar(max), varbinary(max), xml, или image нельзя указывать в качестве ключевых столбцов индекса.

    INCLUDE
        В списке INCLUDE допускаются данные всех типов, за исключением text, ntext и image.
        Индекс должен создаваться или перестраиваться в автономном режиме (ONLINE = OFF), если один из указанных неключевых столбцов varchar(max), nvarchar(max) или varbinary(max).

        Вычисляемые столбцы, являющиеся детерминированными и точными или неточными, могут быть включенными столбцами.
        
        Вычисляемые столбцы, производные от image, ntext, text, varchar(max), nvarchar(max), varbinary(max), 
        и xml типы данных могут быть включены в неключевых столбцов, при условии, что тип данных вычисляемого столбца является допустимым в качестве включенного столбца.
    WHERE
        Отфильтрованный индекс должен быть некластеризованным индексом для таблицы. 
        Создается отфильтрованная статистика для строк данных отфильтрованного индекса.
        
        Предикат фильтра не может ссылаться на вычисляемый столбец, столбец определяемого пользователем типа, 
        столбец типа пространственных данных или столбец типа hierarchyID.
        
        Отфильтрованные индексы не поддерживают параметр IGNORE_DUP_KEY.    
    ON partition_scheme_name ( column_name )
        Задает схему секционирования.
        column_name указывает столбец, по которому будет секционирован индекс.
        
        column_name предназначен не только для столбцов в определении индекса.
        
        Любой столбец в базовой таблице, можно указать, за исключением при секционировании UNIQUE индекса, 
        column_name должен быть выбран из используемых в уникальном ключе.
        
        Это ограничение дает возможность компоненту Database Engine проверять уникальность значений ключа только в одной секции.

        При секционировании неуникального кластеризованного индекса компонент Database Engine по умолчанию добавляет столбец секционирования в список ключей кластеризованного индекса, если этого столбца еще нет в списке.
        При секционировании неуникального некластеризованного индекса компонент Database Engine добавляет столбец секционирования как неключевой (INCLUDE) столбец индекса, если этого столбца еще нет в списке.

        Если partition_scheme_name или файловая группа не указана и таблица секционирована, 
        индекс помещается в ту же схему секционирования, с тем же столбцом секционирования, что и базовая таблица.
    ON filegroup_name
        Создает заданный индекс в указанной файловой группе.
        
        Если местоположение не указано и таблица или представление не секционированы, 
        индекс использует ту же файловую группу, что и базовая таблица или базовое представление.
        
        Файловая группа должна существовать.
    ON default
        Создает заданный индекс в файловой группе, используемой по умолчанию.        
    relational_index_option
        FILLFACTOR
            Определяет количество пустого пространства для размещения на каждой странице данных индекса при его создании. 
            Применяется только во время создания или восстановления индекса.
        PAD_INDEX
            Указывает, должен ли FILLFACTOR для индекса применяться к не листовым страницам данных для индекса.
        SORT_IN_TEMPDB
            Определяет, следует ли хранить временные результаты при создании индекса в базе данных tempdb. Увеличивает использование места на диске, которое используется при индексировании.
        IGNORE_DUP_KEY
            Определяет ответ на ошибку, случающуюся, когда операция вставки пытается вставить в уникальный индекс повторяющиеся значения ключа. 
            Параметр IGNORE_DUP_KEY применяется только к операциям вставки, производимым после создания или перестроения индекса.
            Если в уникальный индекс вставляются повторяющиеся значения ключа, выводится предупреждающее сообщение. С ошибкой завершаются только строки, нарушающие ограничение уникальности.
        STATISTICS_NORECOMPUTE
            Указывает, следует ли воссоздать любую статистику, связанную с индексом, при создании индекса.
        STATISTICS_INCREMENTAL
            Указывает, должна ли создаваться статистика для индекса в целом или для каждого раздела.
        DROP_EXISTING
            Определяет поведение, когда индекс с тем же именем в таблице уже существует.
            Когда установлено значение ON, создание индекса будет перезаписывать существующий индекс.
        ONLINE
            Определяет, будут ли базовые таблицы и связанные индексы доступны для запросов и изменения данных во время операций с индексами.
            Это функция Enterprise Edition.
        ALLOW_ROW_LOCKS
            Определяет, разрешены ли блокировки строк в индексе.
        ALLOW_PAGE_LOCKS
            Определяет, разрешены ли блокировки страниц для индекса.
        MAXDOP
            Переопределяет максимальная степень параллелизма параметр конфигурации в течение операции с индексами.
        DATA_COMPRESSION
            Определяет тип сжатия данных для использования в индексе.
        
            ON PARTITIONS
                Указывает секции, к которым применяется параметр DATA_COMPRESSION.

При изменении индекса ключевые и включенные столбцы нельзя изменить. 
Для этого синтаксис CREATE INDEX используется с опцией DROP_EXISTING.

Табличные подсказки.
    WITH ( INDEX (index_value [,... n ] ) | INDEX = ( index_value) )
    
    При использовании подсказок INDEX, вы должны документировать их или исследовать, 
    где индекс может быть использован до его удаления.

Требования к месту на диске (см. https://docs.microsoft.com/ru-ru/sql/relational-databases/indexes/disk-space-requirements-for-index-ddl-operations).
    Дополнительное место на диске не требуется для следующих операций с индексами:
        - ALTER INDEX REORGANIZE (необходимо место для журнала);
        - DROP INDEX (при удалении некластеризованного индекса);
        - DROP INDEX (при удалении вне сети кластеризованного индекса без предложения MOVE TO и в отсутствие некластеризованных индексов);
        - CREATE TABLE (PRIMARY KEY или ограничение UNIQUE).
        
    Дополнительное место на диске требуется для следующих операций с индексами:
        - CREATE INDEX;
        - CREATE INDEX WITH DROP_EXISTING;
        - ALTER INDEX REBUILD;
        - ALTER TABLE ADD CONSTRAINT (PRIMARY KEY или ограничение UNIQUE);
        - ALTER TABLE DROP CONSTRAINT (ограничение PRIMARY KEY или UNIQUE) если ограничение основано на кластеризованном индексе;
        - DROP INDEX MOVE TO (применяется только к кластеризованным индексам).
        
    Пример расчета места на диске см. https://docs.microsoft.com/ru-ru/sql/relational-databases/indexes/index-disk-space-example.
    
Обслуживание индексов:
    - Фрагментация индексов.
    - Раздувание кучи и указатели переадресации (forwarding).
    - Фрагментация columnstore.
    - Статистика.
    - Статистика In-Memory.