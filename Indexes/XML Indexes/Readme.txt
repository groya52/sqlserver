Индексирование XML состоит из двух категорий: первичного и вторичного индексов.

Для каждой таблицы можно создать до 249 XML индексов.
    
Первичный XML индекс.
    Когда создается первичный XML индекс, SQL Server разбивает XML данные в данном столбце в реляционный формат, доступный только механизму выполнения запроса. 
    Это потенциально может поглотить более чем вдвое объем памяти, необходимый для хранения необработанных XML данных.
    
    При создании первичного XML индекса необходимо следовать нескольким правилам:
        - Таблица, содержащая столбец XML, должна иметь кластерный первичный ключ.
        - Когда существует первичный XML индекс, кластерный первичный ключ таблицы не может быть удален или изменен с помощью операторов DDL.
        Перед изменением первичного ключа все индексы XML должны быть удалены.
        - Первичный XML индекс может быть создан в одном столбце типа XML.
        - Каждый XML индекс должен иметь уникальное имя для всей базы данных.
        - Вы не можете отдельно указывать файловую группу или информацию о секционировании для таблицы пользователя при создании XML индекса.
        Если базовая таблица секционирована, XML индекс использует ту же схему секционирования, что и таблица.
        - Когда первичный XML индекс удаляется, все вторичные индексы XML, полагающиеся на него, автоматически удаляются.
        Для этого действия не будет показано предупреждение.
        - Установите IGNORE_DUP_KEY и ONLINE опции OFF для индексов XML.
        - Первичные индексы XML имеют те же ограничения на имена, что и представления на их имена.
        - Только таблицы с столбцом типа XML могут иметь XML индекс. 
        Представления, табличные переменные с столбцами типа XML, или переменные типа XML не могут иметь индекс XML.
        - Никакие XML индексы не должны существовать при изменении столбца типа XML из нетипизированного в типизированный XML.
        Параметр ALTER TABLE ALTER COLUMN может использоваться, если в таблице существует индекс XML. Индексы XML должны быть удалены до того, как тип столбца может быть изменен.
        - Следующие параметры сеанса должны быть установлены в ON при создании индекса XML:
            ARITHABORT
            ANSI_NULLS
            ANSI_PADDING
            ANSI_WARNINGS
            CONCAT_NULL_YIELDS_NULL
            QUOTED_IDENTIFIER
        - Параметр NUMERIC_ROUNDABORT должен быть установлен в положение OFF, когда создается индекс XML.
            
Вторичный XML индекс.    
    Вторичный индекс XML расширяет первичный индекс, включая пути, значения и свойства.
    
    Вторичный индекс XML не может существовать без первичного XML индекса.
    
    Типы вторичных XML индексов:
        PATCH
            Вторичный XML индекс типа PATCH повышает производительность запросов для метода exist() типа данных XML.
        VALUE
            Может повысить эффективность XQuery, когда путь не полностью указан или включает подстановочные знаки.
            
            Однако этот метод может замедлить производительность для столбца типа данных XML, в котором экземпляр XML имеет глубоко вложенные элементы.Это одна из наиболее распространенных проблем с производительностью в процессе измельчения XML.Поэтому я бы рекомендовал (когда это возможно) предоставить более подробный путь в методе nodes () . Например, XML_Column.nodes ('// ELEMENT / CHILD_ELMNT') может улучшить производительность измельчения XML.
        PROPERTY 
            Индекс вторичного типа PROPERTY может обеспечить преимущества производительности при запросе столбца XML, который извлекает одно или несколько значений с помощью метода value().
    
Выборочный XML индекс (SQL SERVER 2012).
    Селективный XML индекс предназначен для улучшения производительности XQuery и хранения XML индексов для столбца XML, в котором хранятся большие документы XML.
    
    Преимущество создания выборочного XML индекса заключается в том, что вы можете реализовать один или несколько путей XML, чтобы сосредоточиться на значениях XML, которые в основном используются в ваших критериях поиска.
    
    Чтобы создать выборочный индекс XML, вы должны соответствовать следующим критериям:
        - Таблица должна иметь кластерный первичный ключ.
        - Размер ключа ограничен 128 байтами.
        - Ключевые столбцы ограничены 15.
        
    Селективный XML не будет использоваться для методов query() или modify() в операциях XQuery. Он будет поддерживать exist(), value() и nodes().
        
    Подсказки выборочного индекса XML:
        Подсказка   Относится              Описание
        node()      XQuery                 Уменьшает объем требуемого хранения. Проверьте наличие узла.
        SINGLETON   XQuery and SQL Server  Обеспечивает уверенность, что есть только один экземпляр группы, чтобы индекс можно было оптимизировать с учетом этого. 
                                           Избегайте добавления дополнительных экземпляров впоследствии, так как это может вызвать проблемы.
        DATA TYPE   XQuery                 Оптимизирует индекс с помощью типов данных. Проблема может возникнуть, если что-то сломает тип данных, затем в индексе отобразится NULL.
        MAXLENGTH   XQuery                 Полезно посмотреть на строку XQuery типа xs:string и оптимизировать индекс с максимально допустимым значением для строк. 
                                           Однако это может вызвать проблему, если существующая строка длиннее указанного MAXLENGTH, поскольку индекс может завершиться ошибкой.
    
    Типы данных XQuery, подходящие для поиска:
        Типизированный XML     Нетипированный XML
        xs:anyUri              
        xs:boolean             xs:boolean
        xs:date                xs:date
        xs:dateTime            xs:dateTime
        xs:day                 
        xs:decimal             
        xs:double              xs:double
        xs:float               
        xs:int                 
        xs:integer             
        xs:language            
        xs:long                
        xs:name                
        xs:NCName              
        xs:negativeInteger     
        xs:nmtoken             
        xs:nonNegativeInteger
        xs:nonPositiveInteger
        xs:positiveInteger
        xs:qname
        xs:short 
        xs:string              xs:string
        xs:time                xs:time
        xs:token
        xs:unsignedByte
        xs:unsignedInt
        xs:unsignedLong
        xs:unsignedShort
 
    Эффективность подсказок оптимизации выборочного XML индекса:
        Подсказка    Эффективность  Улучшение
        оптимизации  хранения       производительности
        node()       да             нет
        SINGLETON    нет            да
        DATA TYPE    да             да
        MAXLENGTH    да             да
        
    Список подсказок оптимизации и типов данных:
        Подсказка    Типы данных XQuery  Типы данных SQL
        оптимизации         
        node()       да                  нет
        SINGLETON    да                  да
        DATA TYPE    да                  нет
        MAXLENGTH    да                  нет
        
    Вторичный выборочный XML индекс.
        Вторичный выборочный индекс XML повышает производительность выборочного индекса XML.
        Синтаксис подобен синтаксису вторичного индекса XML, главным отличием которого является то, что выборочный индекс XML указан в предложении USING XML INDEX, а предложение FOR реализует один из выборочных путей индекса XML.
        
        CREATE XML INDEX <SECONDARY_SELECTIVE_XML_Index_Name> ON <Table_Name> ( <Column_Name> )
        USING XML INDEX ( <SELECTIVE_XML_Index_Name> )
        FOR ( <PathName> )
    
        Вторичный выборочный XML-индекс должен иметь путь с продвинутым типом данных.
        
Каждый оператор ALTER INDEX восстанавливает весь индекс.
Поэтому, по соображениям эффективности, более практично реализовать список изменений в одной инструкции ALTER INDEX вместо запуска инструкции ALTER INDEX несколько раз.

        
        
        



