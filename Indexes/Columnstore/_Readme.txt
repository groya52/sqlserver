Типы индексов columnstore:
    SQL Server 2012 
        Некластеризованный индекс columnstore только для чтения (на куче или клатеризованном индексе (B-tree), 
        делает таблицу только для чтения).
    SQL Server 2014 
        Некластеризованный индекс columnstore только для чтения (на куче или клатеризованном индексе (B-tree), 
        делает таблицу только для чтения).
        
        Кластеризованный индекс columnstore в качестве единственного индекса в таблице.
    SQL Server 2016
        Обновляемый некластеризованный индекс columnstore (на куче или клатеризованном индексе (B-tree)).
        Кластеризованный индекс columnstore в качестве единственного индекса в таблице.
        Кластеризованный индекс columnstore c некластеризованными индексами (B-tree).
        Кластеризованный индекс columnstore для таблиц оптимизированных для памяти.
        Отфильтрованный некластеризованный индекс columnstore.
        
Ограничения индексов columnstore:
    Не могут иметь более 1024 столбцов или включать разреженные столбцы. 
    Не могут быть использованы с таблицами, которые используют FILESTREAM или репликацию.
    Не могут быть созданы в индексированном представлении.
    
    Не поддерживаются типы данных binary, varbinary, (n)text, image, (n)varchar(max), timestamp, CLR, sql_variant, xml.
    SQL Server 2012 не поддерживает следующие типы данных: uniqueidentifier, decimal и numeric 
    с точностью более 18 цифр или datetimeoffset с точностью более 2 цифр.

Некластеризованные индексы columnstore только для чтения (NCCI) (SQL Server 2012-2014).	
	Когда создается индекс columnstore в SQL Server 2012, он запрашивает грант памяти размера, 
    который можно приблизительно оценить по следующей формуле:
		
		Memory Grant Request (MB) = (4.2 * Number of columns in the index + 68) * (Degree of Parallelism) +
			(Number of text columns in the index * 34)
			
	Процесс создания индекса выходит из строя в случаях недостаточной памяти.
	
	Существует два способа решения этой проблемы, помимо добавления большего количества памяти на сервер:
		- Уменьшить степень параллелизма с опцией индекса MAXDOP.
		  Хотя этот параметр уменьшает требования к памяти для запроса, 
          он увеличивает время создания индекса пропорционально уменьшению DOP.
		- Изменить свойство REQUEST_MAX_MEMORY_GRANT_PERCENT группы рабочей нагрузки в Resource Governor.
		  По умолчанию размер разрешения памяти запроса ограничен 25 процентами доступной памяти рабочего пространства, 
		  которую вы можете увеличить на время действия оператора CREATE INDEX.
          
	Некластеризованные индексы columnstore делают таблицу с таким индексом доступной только для чтения.
		  
	Таблицы с индексами столбцов поддерживают переключатель разделов, 
    что является отличным вариантом для импорта данных в таблицу. 
    
	Можно создать промежуточную таблицу, импортировать в нее данные, 
    a затем добавить индекс columnstore в промежуточную таблицу при завершении импорта, 
	a затем перевести промежуточную таблицу в новый раздел в основной таблице только для чтения
	
	Можно использовать секционированное представление, 
    которое объединяет данные из обновляемых таблиц и таблиц только для чтения с индексами columnstore.
	
    Использование предложения UNION ALL в SQL Server 2012 отключает выполнение пакетного режима.
Кластерные индексы столбцов (CCI) (SQL Server 2014-2016)
    Таблицы с кластерными индексами столбцов не могут содержать никаких других индексов (B-tree, некластеризованные индексы columnstore).

	SQL Server 2014 автоматически настраивает DOP на основе доступной памяти. 
	Такое поведение уменьшает вероятность отказа процесса создания индекса из-за отсутствия памяти.

    В SQL Server 2016 вы можете определить некластеризованные индексы B-tree для таблиц с кластерными индексами columnstore.
    
    SQL Server 2014 и 2016 не позволяют определить триггеры в таблице c индексами columnstore.
    
    В SQL Server 2014 таблица не может ссылаться на другие таблицы 
    и так же иметь ссылатющиеся на нее ограничения внешнего ключа.
    
    Вы не можете запрашивать таблицы с кластеризованными индексами columnstore 
    на читаемых вторичных группах доступности AlwaysOn.
    
    SQL Server 2016 устраняет эти ограничения, однако поддержка уникальности,
    ссылочной целостности и ограничений первичного ключа потребует создания некластеризованных индексов B-tree.
        
    Репликация, отслеживание изменений и сбор данных изменений не поддерживаются даже в SQL Server 2016.

Некластеризованные индексы B-tree (SQL Server 2016).
    Некластеризованные индексы B-tree также позволяют определять и применять первичные ключи 
    и уникальные ограничения для таблиц c кластеризованным индексом columnstore.
    
    Они также позволяют этим таблицам ссылаться на другие таблицы или иметь ссылатющиеся на нее ограничения внешнего ключа. 
    Все это помогает улучшить качество данных в системах хранилищ данных.
                       
    Когда таблица с кластеризованным индексом columnstore секционирована, 
    SQL Server также разделяет некластеризованные индексы B-Tree, выравнивая их с индексом columnstore.
    
    Это может помешать вам определить уникальность индекса, 
    если вы не включили столбец секционирования в индексный ключ (см. рис. Таблица с кластеризованным columnstore индексом и некластеризованным индексом B-tree.jpg).
        
    Cтроки в индексах columnstore могут перемещаться в разные местоположения, 
    например, когда delta store сжимаются или группируются группы строк.
    
    Когда это произойдет, SQL Server не обновляет идентификатор строки в некластеризованных индексах, 
    а использует другой внутренний компонент, называемый индексом отображения (mapping index),
    который содержит информацию о старых и новых расположениях строк.
    
    Внутри индекс отображения может отслеживать перемещение отдельных строк вместе 
    с перемещением нескольких строк и изменениями идентификатора группы строк.
        
    Когда перемещается строка в индексе columnstore, 
    SQL Server отслеживает original locator строки во внутреннем nullable столбце в индексе columnstore.
    Этот столбец создается, когда вы добавляете первый некластеризованный индекс B-tree в таблицу. 
    Это значение original locator однозначно идентифицирует соответствующие строки в 
    некластеризованных индексах B-tree и используется, когда вы, например, удаляете строку из таблицы.
    Значение original locator не заполняется до тех пор, пока строка не будет перемещена.
    
    Можно увидеть столбец original locator, если вы просмотрите содержимое страницы данных delta store 
    или просмотрите информацию сегмента индекса columnstore с представлением sys.column_store_segments.
        
    Восстановление кластерного индекса columnstore перестраивает строки в группах строк, меняя их местоположение.
    SQL Server будет восстанавливать некластеризованные индексы B-tree и удалять mapping indexes.
  
Обновляемые некластеризованные индексы columnstore (SQL Server 2016).
    Некластеризованные индексы columnstore в SQL Server 2016 подобно кластерным индексам columnstore, 
    используют delta store и delete bitmap изображение для поддержки изменений данных (см. рис. Комоненты кластеризованного индекса B-tree и некластеризованного индекса columnstore.jpg).
    
    Однако их delta store не ограничены 1 048 576 рядами и могут вырасти примерно до 33,5 миллионов строк (2 ^ 25).

    Существует еще одна структура, называемая delete buffer,
    которая используется в качестве временного хранилища для информации об удаленных строках.
    Это уменьшает накладные расходы, на управления delete bitmap, введя OLTP транзакции.

    Delete buffer реализуется как индекс B-tree со структурой, которая имитирует идентификатор строки таблицы, 
    который является либо кластеризованным индексным ключом, либо местоположением строки в таблице кучи.
    
    Такой подход позволяет SQL Server избегать поиска указателя строки индекса columnstore, 
    который используется в delete bitmap во время операций DELETE и UPDATE.
        
    COMPRESSION_DELAY 
        
Индексы columnstore включают несколько преимуществ производительности, таких как:
    - Хранение столбцов. 
      Поскольку запросы хранилища данных обычно выбирают только несколько столбцов таблицы фактов, 
      чтение только страниц для требуемых столбцов имеет огромную экономию ввода-вывода.
      Столбцы, которые не нужны для запроса, не обязательно должны быть прочитаны.
    - Сжатие. 
      Поскольку данные из одного и того же столбца хранятся на одних и тех же страницах, аналогичные данные сохраняются смежно, 
      что означает высокую степень сжатия, снова сохраняя ресурсы ввода-вывода.
    - Выполнение в пакетном режиме. 
      В пакетном режиме подсистема выполнения запросов обрабатывает данные в группе из 900 значений.
    - Устранение сегмента.
      Как упоминалось ранее, данные для одного и того же столбца хранятся на одной странице,
      а несколько страниц группируются в сегмент.
      
      Подобно концепции исключения разделов,
      сегменты можно исключить в зависимости от значений, используемых для запроса.
    - Статические вычисления.
      В SQL Server 2016, агрегаты выталкиваются вниз и предварительно рассчитанных на двигатель хранения.
      Агрегаты могут быть перенесены на операцию сканирования, улучшая производительность.
      
Одним из усовершенствований SQL Server 2016 является возможность использования пакетного режима в последовательных планах,
когда уровень совместимости базы данных установлен в 130.

Во-вторых, как обычные индексы B-Tree, индексы некластеризованного столбца содержат идентификатор строки,
который является либо адресом строки в таблице кучи, либо значением кластерного индекса.

В последнем случае все столбцы из кластерного индекса включаются в индекс столбцов,
даже если вы явно не определяете их в инструкции CREATE COLUMNSTORE INDEX.

Несколько факторов повышают эффективность систем баз данных хранилища данных:
    - Cтремиться уменьшить размеры строк и столбцов, используя соответствующие типы данных;
    - Избегать нулевых столбцов;
    - Используйте ограничения CHECK и UNIQUE, когда это необходимо;
    - Избегайте использования столбцов строк в таблицах фактов, когда это возможно.