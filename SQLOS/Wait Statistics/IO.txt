ASYNC_IO_COMPLETION
    Тип ожидания ASYNC_IO_COMPLETION возникает, когда вы выполняете действия, связанные с подсистемой хранения, изнутри экземпляра SQL Server, в первую очередь резервные копии базы данных и создание новых баз данных.
    Пока выполняется действие, связанное с хранением, регистрируется время ожидания ASYNC_IO_COMPLETION. 
    Чем быстрее будет подсистема хранения, тем ниже будет время ожидания ASYNC_IO_COMPLETION.
    
    Одной из распространенных причин высокого времени ожидания ASYNC_IO_COMPLETION является резервное копирование базы данных.
    Чтобы узнать, происходит ли ваш ASYNC_IO_COMPLETION, потому что выполняется резервное копирование, попробуйте искать связанные с резервным копированием ожидания, происходящие одновременно.
    
        SELECT * 
        FROM   sys.dm_os_wait_stats 
        WHERE  wait_type IN ('ASYNC_IO_COMPLETION', 'BACKUPIO', 'BACKUPBUFFER');
        
    Другим возможным способом снижения ожиданий ASYNC_IO_COMPLETION является настройка мгновенной инициализации файла (инициализация мгновенных файлов не включена по умолчанию, если только вы не используете службу SQL Server под учетной записью с правами локального администратора).
    Это не влияет на скорость вашей резервной копии, но даст большую производительность при создании базы данных, добавлении файлов в базу данных или восстановлении базы данных.
    
    Если вы настроили мгновенную инициализацию файла и отметили, что резервное копирование не выполняется одновременно с ожиданием высокого ожидания ASYNC_IO_COMPLETION, проблема может быть в вашей подсистемой хранения.
    
    Хорошим методом анализа потенциальных проблем хранения является использование Perfmon для счетчиков Avg. Disk/sec Read и Avg. Disk/sec Write.
    Задержка выше 20 миллисекунд  вызовет заметное ухудшение производительности. Чем выше значение задержки, тем выше время ожиданий, связанных с хранением.
    
ASYNC_NETWORK_IO
    Тип ожидания ASYNC_NETWORK_IO связан с пропускной способностью вашего сетевого соединения между экземпляром SQL Server и вашими клиентами.
    Пока SQL Server ожидает отправки запрошенных данных, регистрируется тип ожидания ASYNC_NETWORK_IO. Другая ситуация, в которой ожидание ASYNC_NETWORK_IO, может возникнуть, когда вы используете связанный сервер для запроса удаленных баз данных.
    
    Одним из самых простых способов снизить ожидания ASYNC_NETWORK_IO является идентификация запросов, которые возвращают большой результат, возвращаемый в приложение.
    
    Если вы считаете, что ожидания ASYNC_NETWORK_IO не вызваны большими результатами, возвращаемыми в приложение, или скоростью, с которой приложение может обрабатывать результаты, также существует вероятность того, что ваша сетевая конфигурация замедляет работу. 
    В этом случае вы должны сначала проверить использование сети. К сожалению, в Perfmon нет счетчика, который напрямую показывает использование сети, если вы не выполните математику для ее расчета. 
    Вместо этого вы можете использовать вкладку Сеть диспетчера задач для просмотра использования сетевой карты.
    Если вы заметили, что использование сети является высоким, в то время как вы испытываете ожидания ASYNC_NETWORK_IO больше, чем обычно, возможно, что сеть замедляет работу.
    
CMEMTHREAD
    Ожидание CMEMTHREAD связано с памятью и указывают на давление определенных объектов памяти, связанных с SQL Server.
    Всякий раз, когда происходит CMEMTHREAD, это означает, что несколько потоков одновременно пытаются получить доступ к одному и тому же объекту памяти.
    
    Поскольку в SQL Server существует много различных объектов памяти, которые могут потенциально генерировать CMEMTHREAD, существует множество возможных решений для снижения времени ожидания CMEMTHREAD в зависимости от объекта памяти, к которому обращаются.
    
    Хорошее место для поиска, если вы подозреваете, что ожидания CMEMTHREAD происходят из-за специальных запросов - это кеш процедур.
    
        SELECT objtype
              ,COUNT_BIG(*) AS total_cached_plans
              ,SUM(CONVERT(NUMERIC(12,2), size_in_bytes)) / 1024 / 1024 AS size_in_mb
        FROM   sys.dm_exec_cached_plans 
        GROUP  BY objtype;
        
    Если вы увидите, что это число быстро растет и появляются ожидания CMEMTHREAD, возможно, стоит попытаться проанализировать некоторые из этих специальных запросов.
    Попробуйте оптимизировать запросы, чтобы они генерировали многоразовые планы.
    Если ваше приложение использует много динамических запросов, попробуйте использовать системную хранимую процедуру sp_executesql.
    
IO_COMPLETION
    Ожидание IO_COMPLETION возникает при попытке доступа к подсистеме хранения данных.
    
    Ожидания IO_COMPLETION происходят, когда SQL Server ожидает завершения операций с страницами без данных, например, операции восстановления журнала транзакций или чтения растровых страниц, например страницы GAM. 
    
    Ожидания IO_COMPLETION происходят совершенно нормально, и они часто не требуют более глубокого анализа, если время ожидания не намного превышает значения в исходном состоянии.
    В этих случаях сначала сосредоточитесь на производительности вашей подсистемы хранения.

    Ожидание IO_COMPLETION происходят, когда SQL Server ожидает завершения действий, связанных с хранением.
    
    Ожидание IO_COMPLETION происходят, когда задействуются страницы без данных, например восстановление резервной копии журнала транзакцийили когда доступны страницы распределения растровых изображений, такие как страница GAM. 
    Ожидания IO_COMPLETION также могут возникать при выполнении запросов, которые выполняют операции чтения или записи в хранилище, как и оператор Merge Join.
    
    Ожидания IO_COMPLETION возникает, когда вы запускаете свои базы данных после, например, перезапуска службы SQL Server. Это означает, что вы должны ожидать, что IO_COMPLETION ждет после перезагрузки или перехода на другой ресурс, это совершенно нормально.
    
LOGBUFFER & WRITELOG
    Ожидание WRITELOG появляется каждый раз, когда записи журнала записываются в журнал транзакций (см. Движение транзакций и типы ожидания LOGBUFFER & WRITELOG.jpg).
    Ожидания LOGBUFFER возникает при вставке записей журнала в буфер журнала, когда во время вставки SQL Server должен ждать свободного пространства внутри буфера журнала (см. Движение транзакций и типы ожидания LOGBUFFER & WRITELOG.jpg).
    
    Такая ситуация часто возникает в системах с большим количеством одновременных модификаций данных. Это приводит к большому объему транзакций, которые необходимо записать на диск.
    Другой распространенной причиной является производительность подсистемы хранения, в которой находится файл журнала транзакций. 
    Если подсистема хранения имеет субоптимальную производительность, время ожидания WRITELOG увеличится, и существует вероятность, что LOGBUFFER ждет, если объем транзакций достаточно высок.
    
    Частое создание небольших блоков обычно происходит медленнее, чем запись больших блоков с большим интервалом, которые бы сбрасывались в журнал транзакций, что приводило к повышению производительности.
    
    Если SQL Server не может записывать записи журнала достаточно быстро, вы можете столкнуться с LOGBUFFER и WRITELOG.
    В качестве наилучшей практики обязательно разделите файлы транзакций и файлы данных базы данных на отдельные диски, чтобы они не влияли друг на друга во время большой нагрузки.
    Также контролируйте диск, на котором находится журнал транзакций, с использованием счетчиков производительности диска в Perfmon, например Avg. Disk sec/write, чтобы показать латентность записи и Disk Writes/sec, чтобы показать IOPS записи и проверить, находятся ли значения в допустимом диапазоне.
    
    Можно использовать опцию Delayed Durability, которая была введена в SQL Server 2014. 
    Включение этой опции больше не будет скидывать содержимое буфера журнала на диск, когда происходит COMMIT транзакции, а скорее будет ждать, пока буфер журнала будет заполнен (60 КБ), прежде чем скидывать содержимое в журнал транзакций.
    Включив этот параметр, вы рискуете, что транзакции, которые были совершены, но еще не были записаны в журнал транзакций, будут потеряны во время сбоя, поскольку они будут записаны только в журнал транзакций, когда буфер журнала заполнен.
    
RESOURCE_SEMAPHORE 
    Прежде чем семафор ресурсов предоставит запрошенную память запросу, он проверит, достаточно ли свободной памяти для ее выполнения.
    Если по какой-то причине меньше доступной памяти, чем сумма, запрошенная запросом, запрос снова будет помещен в очередь, пока не будет доступно достаточное количество памяти. 
    Когда запрос находится внутри очереди семафора ресурсов, ожидающей его запрошенной памяти, время, которое он проводит внутри очереди, будет записано как тип ожидания RESOURCE_SEMAPHORE.
    
    В актуальном плане запроса, мы можем взглянуть на объем памяти, необходимый для его выполнения, посмотрев MemoryGrantInfo внутри свойств плана выполнения:
        GrantedMemory
            Предоставленная семафором ресурсов память.
        DesiredMemory 
            Память запрошенная запросом, представляет собой сумму требуемой и дополнительной памяти.
        RequiredMemory
            Минимальный объем памяти, необходимый для выполнения запроса.
            
        Когда вы используете параллелизм в своих запросах, для выполнения операции требуется больше памяти, так как работа разделяется между потоками.
        
    EXEC sys.sp_configure N'max server memory (MB)', N'250';
    GO 
    RECONFIGURE WITH OVERRIDE 
    GO
    
    Существуют различные другие ресурсы, которые мы можем использовать для анализа ожиданий RESOURCE_SEMAPHORE. 
    У самих семафоров ресурсов есть свои DMV, sys.dm_exec_query_resource_semaphores, который будет возвращать информацию об их потреблении памяти и выдающихся и ожидающих грантах.
    
    Мы также можем использовать Perfmon для контроля общего размера предоставленной памяти, просмотрев счетчик SQLServer:Memory Manage\Granted Workspace Memory (KB).
    
RESOURCE_SEMAPHORE_QUERY_COMPILE
    Указывает на нехватку памяти во время процесса компиляции запроса.
    
    
ДОЧИТАТЬ РАЗОБРАТЬСЯ