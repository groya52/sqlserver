Сообщения об ошибках.
    Сообщение об ошибке в SQL Server состоит из следующих частей:
        Номер ошибки.
            Сообщения об ошибках SQL Server нумеруются от 1 до 49 999. Пользовательские сообщения об ошибках нумеруются с 50 001 и выше (50 000 зарезервирована для пользовательского сообщения, которое не имеет номера пользовательской ошибки).
        Уровень серьезности.
            В SQL Server определено 26 уровней серьезности с номерами от 0 до 25 (от 16 и выше автоматически записываются в журнал SQL Server и в журнал приложений Windows):
                - 0-9 информационные ошибки;
                - 10 никогда не возникает;
                - 11-16 регулярные ошибки SQL (нарушения ограничения, ошибки разрешений и т.д.);
                - 17-19 програмные ошибки (нехватка дискового пространства или памяти), не могут быть исправленны пользователем;
                - 20-24 указывают на системные проблемы и являются неустранимыми ошибками (считаются фатальными (неустранимыми) и приводят к разрыву соединений и откату всех открытых транзакций).
        Cостояние.
            Целое число с максимальным значением 127, используемое компанией Microsoft для внутренних целей.
        Имя процедуры.
            Имя хранимой процедуры, триггера или пользовательской функции, где произошла ошибка.
        Номер строки.
            На какой строке в процедуре или триггере произошла ошибка.
        Сообщение об ошибке.
            Может иметь длину до 255 символов в кодировке Unicode. Сообщения об ошибках SQL Server перечислены в представлении каталога sys.messages. Можно добавлять пользовательские сообщения об ошибках с помощью процедуры sp_addmessage.

    Команда THROW.
        ;THROW [ { error_number | @local_variable }
                ,{ message | @local_variable }
                ,{ state | @local_variable } ]
        [;]
        
        error_number
            Номер ошибки не требует соответствующего сообщения, определенного в представлении каталога sys.messages (можно выбрать любой номер ошибки от 50000 и выше).
        message
            % является зарезервированным символом в тексте сообщения инструкции THROW, и его необходимо экранировать (дважды укажите знак %, чтобы получить % в тексте сообщения).
        state
            Параметр состояния должен быть целым числом в диапазоне от 0 до 255.
            
        Может использоваться без параметров в блоке CATCH конструкции TRY/CATCH.
        
        Уровень серьезности ошибки всегда устанавливается равным 16.
            
        Команда THROW всегда прерывает выполнение пакета, за исключением случаев, когда она используется в блоке TRY.
        
    Команда RAISERROR.
        RAISERROR ( { msg_id | msg_str | @local_variable }  
                    { ,severity ,state }  
                    [ ,argument [ ,...n ] ] )  
        [ WITH option [ ,...n ] ]
            
        msg_id
            В sys.messages хранятся номера пользовательских сообщений об ошибоках. С помощью sp_addmessage можно добавлять пользовательские сообщения об ошибках, номера пользовательских сообщений об ошибках должны быть больше 50 000.
        msg_str
            Когда указывается текст сообщения в команде RAISERROR, номер ошибки всегда будет 50000. В сообщении об ошибке, можно использовать параметры подстановки.
        severity
            Уровень серьезности, указанный в инструкции RAISERROR, переопределяет уровень серьезности, указанный в sp_addmessage.

            Степень серьезности от 0 до 18 может указать любой пользователь, от 19 до 25 указываются только членами предопределенной роли сервера sysadmin или пользователи с разрешениями ALTER TRACE (требуется параметр WITH LOG). 
            
            Указав -1, будет получена степень серьезности, связанная с ошибкой.
            
            Если инструкция RAISERROR с уровнем серьезности 11 или выше выполняется в блоке TRY, управление передается соответствующему блоку CATCH.
            
            Рекомендуется:
                - 0 (или 10) - информационные сообщений с WITH NOWAIT; 
                - 16 - регулярные ошибки;
                - 20 - неустранимые ошибки.
        state
            Целое число от 0 до 255.
            
            При создании одного и то же сообщения об ошибке в нескольких местах, рекомендуется использовать разные значения для параметра состояния, для того, чтобы определить, где в коде появилось сообщение об ошибке.
        option
            LOG	
                Ошибка регистрируется в журнале ошибок и журнале приложений для экземпляра Microsoft SQL Server. Сообщения об ошибках в журнале ошибок ограничены размером в 440 байт.
                Могут указать только члены фиксированной серверной роли sysadmin или пользователи с разрешением ALTER TRACE.
            NOWAIT
                Немедленно посылает сообщения клиенту.
                
    Функция FORMATMESSAGE
        FORMATMESSAGE ( { msg_number  | ' msg_string ' } , [ param_value [ ,...n ] ] )
        
        msg_number
            Идентификатор сообщения, сохраненного в представлении каталога sys.messages.
        msg_string
            Cообщение не должно содержать более 2 047 символов. Если сообщение содержит 2 048 и более символов, то отображаются только первые 2 044, а за ними появляется знак многоточия.
            
            Можно использовать параметры подстановки.
            
            Если необходимо включить символ процента в строку, нужно данный символ увеличить в четыре раза - %%%%.
        param_value
            Значение параметра для включения в текст сообщения.
            
@@ROWCOUNT и ROWCOUNT_BIG()
    Возвращают число строк, затронутых при выполнении последней инструкции. Это делает необходимым зафиксировать значение в локальной переменной, для дальнейшего анализа числа затронутых строк.
        
@@TRANCOUNT 
    Возвращает число инструкций BEGIN TRANSACTION, выполненных в текущем соединении.
        
TRY/CATCH
    Отлавливает ошибки с уровнем серьезности больше 10 и меньше 20.
    
    Не распознает ошибки компиляции, которые происходят в той же области видимости (ошибки компиляции могут возникать во время выполнения SQL Server из-за отложенного разрешения имен).
    
        CREATE PROC procedure_name
        AS
        BEGIN
            BEGIN TRY
                Ошибка компиляции.
            END TRY
            BEGIN CATCH
                Ошибка компиляции не передается блоку CATCH.
            END CATCH;
        END;
        
        Решение:
            
            BEGIN TRY
                EXEC procedure_name;
            END TRY
            BEGIN CATCH
                Ошибка поймана.
            END CATCH
            
    Находясь внутри блока TRY внешней процедуры, вызвать внутреннюю процедуру с параметром OUTPUT, которая сначала назначает значение OUTPUT параметру, а затем вызывает ошибку, которая передает выполнение блоку CATCH во внешней процедуре.
    Если внешняя процедура теперь обращается к переменной, переданной для OUTPUT параметра, внешняя процедура не увидит значение, назначенное во внутренней процедуре.
            
    В блоке CATCH доступны следующие функции (их значения не изменяются во всем блоке CATCH):
    
        ERROR_NUMBER()
            Возвращает номер ошибки.
        ERROR_MESSAGE()
            Возвращает текст сообщения об ошибке.
        ERROR_SEVERITY()
            Возвращает серьезность ошибки.
        ERROR_STATE()
            Возвращает номер состояния для ошибки.
        ERROR_LINE()
            Возвращает номер строки, в которой возникла ошибка.
        ERROR_PROCEDURE()
            Возвращает имя хранимой процедуры или триггера, в которых произошла ошибка.
                  
        В некоторых ситуациях SQL Server вызывает два сообщения об ошибках, но функции ERROR_XXX() возвращают только информацию об одном из них, таким образом, одно из сообщений об ошибках теряется.
        
    Обработчик CATCH должен выполнить три действия:
        1. Откат любой открытой транзакции.
        2. Повторите ошибку.
        3. Выдайте оператор RETURN с ненулевым возвращаемым значением.
        
    < SQL Server 2012:
        
        BEGIN CATCH 
            ...
            EXEC error_handler_sp; 
            RETURN error_number; 
        END CATCH

    >= SQL Server 2012:

        BEGIN CATCH
            ...
            ;THROW;
        END CATCH
        
SET XACT_ABORT { ON | OFF }
    Поведение по умолчанию в SQL Server, когда нет окружения TRY/CATCH, заключается в том, 
	что некоторые ошибки прерывают выполнение и откатывают любую открытую транзакцию, 
	тогда как с другими ошибками продолжает выполняться следующий оператор.
    
    Когда активирована опция XACT_ABORT, ошибки с уровнем строгости больше 10 вызывают откат транзакции.
    
    Опция XACT_ABORT необходима для более надежной обработки ошибок и транзакций. TRY/CATCH не обнаруживает ошибки компиляции в той же области, открытая транзакция, которая не откатывается в случае ошибки, может вызвать серьезные проблемы.
    
    Ограничения:
        - нельзя перехватить ошибку или получить номер ошибки; 
        - любая ошибка с уровнем серьезности более 10 приводит к откату транзакции;
        - никакой оставшийся код в транзакции не выполняется; 
        - после прерывания транзакции можно понять, в какой инструкции произошел сбой, только на основании сообщения об ошибке, возвращенного клиенту от SQL Server.
         
    Параметр XACT_ABORT ведет себя иначе, когда используется в блоке TRY, 
	при возникновении ошибки передает управление блоку CATCH, и любая ошибка становится неустранимой (транзакцию необходимо откатить).
       
XACT_STATE()
    Функция, которая вызывается в блоке CATCH для получения текущего состояния транзакции: 
        1 - есть открытая транзакция, которую можно зафиксировать или откатить;
        0 - нет активной транзакции;
        -1 - есть активная транзакция, но произошла ошибка. Можно выполнить только откат транзакции.
        
    Показывает состояние самой вложенной транзакции.
    
    В версиях SQL 2005 и SQL 2008 XACT_STATE() в системных транзакциях (триггеры, инструкции INSERT-EXEC), всегда равна 0, нет возможно определить, была ли транзакция обречена или нет.
   
SET IMPLICIT_TRANSACTIONS { ON | OFF }
    Запускает неявную транзакцию, которую необходимо явно зафиксировать или отменить.

IGNORE_DUP_KEY
    Вставка дублирующего значения в уникальный индекс, считается ошибкой. Но если уникальный индекс был создан с помощью опции IGNORE_DUP_KEY, ошибка не возникает.
    Дубликат значения отбрасываются и выводится информационное сообщение. Будет вставлена ​​одна из строк источника, но какая из них не определено.
    Не может иметь значение ON для индексов, созданных на представлении, неуникальных индексов, XML-индексов, пространственных индексов и отфильтрованных индексов.
    
    Использование этой опции с постоянной таблицей, содержащей постоянные данные, является грубой ошибкой, другое дело с временными таблицами, табличными переменными и промежуточными таблицами, где набор операций может ограничиваться одной хранимой процедурой. 
    Может быть ситуация, когда ключевые значения в основном уникальны, но есть случайные дубликаты, и все равно, какая строка будет получена.
    В этом случае IGNORE_DUP_KEY не только делает кодирование немного более простым, но также может работать лучше, чем обычные способы удаления дубликатов, таких как DISTINCT или NOT EXISTS.
    Остерегайтесь того, что по мере увеличения частоты дубликатов преимущество производительности IGNORE_DUP_KEY уменьшается.
    
Точки сохранения внутри транзакции.
    При написании кода обработки ошибок в хранимой процедуре можно выбрать, как реагировать на основании того, была ли процедура вызвана из внешней явной транзакции.    
    Например, при обнаружении ошибки в хранимой процедуре, отменить действие процедуры только в том случае, если процедура самостоятельно открыла транзакцию (см. External Transaction Processing.sql).
    
Контексты.
    Пользоватльские функции.
        В пользовательских функциях нельзя использовать инстукцию TRY/CATCH для обрабтки ошибок, также интрукции RAISERROR и THROW для повышения ошибок.
    Триггеры.
        Находясь в теле триггера, вы всегда находитесь в транзакции, даже если вы никогда не выдавали BEGIN TRANSACTION, поскольку триггер логически является частью инструкции, которая запускает триггер.
        В SQL 2005 и SQL 2008 XACT_STATE() вернет 0, если транзакция является системной. XACT_STATE() сообщает значение, если есть явная транзакция пользователя. Это было исправлено в SQL 2012.
        По умолчанию в триггерах XACT_ABORT установлен в ON. Это также относится ко всем хранимым процедурам, вызываемым из триггера.
        Если вы откатываете или завершаете (чего никогда не надо делать) транзакцию в триггере, SQL Server вызывает ошибку 3609.
        Ошибка 266, никогда не возникает при вызове хранимой процедуры из триггера.
    INSERT-EXEC
        см. http://www.sommarskog.se/error_handling/Part2.html#INSERT-EXEC
    BULK INSERT и OPENROWSET (BULK)
        см. http://www.sommarskog.se/error_handling/Part2.html#BULKINSERT2
    Linked Servers
        см. http://www.sommarskog.se/error_handling/Appendix1.html
    CLR модули
        см. http://www.sommarskog.se/error_handling/Appendix2.html
        
XACT_ABORT OFF и TRY-CATCH не применяется.
    1. Невозможно полагаться на то, что ошибка прервет выполнение. Выполнение может продолжаться со следующего оператора.
    2. Невозможно полагаться на то, что вы сможете обработать или зарегистрировать ошибку. Ошибка может прервать выполнение.
    3. Невозможно полагаться на то, что любая открытая транзакция выдержит ошибку.
    4. Невозможно полагаться на то, что будет откат транзакции из-за ошибки.
    5. Невозможно полагаться на то, что вы сможете откатить транзакцию самостоятельно в случае ошибки - выполнение может быть прервано и оставить транзакцию открытой.
    6. Даже если вы не начинаете транзакцию в своей процедуре самостоятельно, когда ваша процедура начинает выполняться, вы не можете полагаться на то, 
       что активная транзакция отсутствует, когда ваша процедура завершается - процедура, которую вы вызываете, может начать транзакцию, а затем выкенуть ошибку компиляции с прерыванием области.
    7. Если у вас открытая транзакция и вызывается другая хранимая процедура, эта процедура может откатить транзакцию при ее возврате.
    
XACT_ABORT ON и TRY-CATCH не используется.
    1. Все еще применимо, но количество ошибок, для которых это может произойти, в значительной степени сокращается.
    2. Полностью применим.
    3. Полностью применим.
    4. Все еще применимо, но количество ошибок, для которых это может произойти, в значительной степени сокращается.
    5. Полностью аннулирован. Если выполнение прерывается, транзакция всегда откатывается - вспомните, что это также относится к сигналам внимания.
    6. Полностью аннулирован. С XACT_ABORT ON эти ошибки прерывают пакет.
    7. Все еще применимо, но количество ошибок, для которых это может произойти, в значительной степени сокращается.
    
XACT_ABORT OFF и TRY-CATCH используется.
    1. Выполнение перенаправляется в блок CATCH.
    2. Все еще применимо, уменьшено. Но вы не можете поймать ошибки компиляции в блоке TRY.
    3. Все еще применимо, сделка может быть обречена.
    4. Все еще применимо, но уменьшено. Ошибки компиляции все еще остаются проблемой.
    5. Все еще применимо, уменьшен для ;THROW.
    6. Аннулирована, поскольку вы можете контролировать это в блоке CATCH.
    7. Аннулирована. Выполнение перенаправляется в блок CATCH.
