Триггеры DML не могут быть определены на временных таблицах, табличных пременных, и in-Mmemory таблицах. На представлениях можно использовать триггеры INSTEAD OF.

Триггеры DML всегда запускаются в контексте транзакции.
          
Триггеры DML AFTER срабатывают только после успешного выполнения всех операций модификации данных. Все каскадные действия и проверки ограничений, на которые имеется ссылка, должны быть успешно завершены, прежде чем триггер сработает.

Триггеры INSTEAD OF срабатывают вместо выполнения операций модификации данных (могут создаваться на представлениях). Триггеры INSTEAD OF запускаются до проверки ограничений.

TempDB
    Триггеры DML AFTER хранят модифицированные данные в TempDB (хранилище версий), сохраняя их до завершения транзакции.
    Чтобы поддерживать связь между новой и старой версиями строк, триггеры AFTER UPDATE и AFTER DELET добавляют 14-байтовый указатель тега версии для строк (необходимо учитывать FILLFACTOR, что бы уменьшить фрагментацию), которые они модифицировали или удалили, и они останутся до тех пор, пока индекс не будет перестроен.

Рекурсия.
    Прямая и косвенная рекурсия триггеров применяется только к триггерам того же типа (AFTER или INSTEAD OF). 

    Прямая.
        Возникает, когда триггер выполняет действие, которое заставляет его рекурсивно запускать самого себя. Триггеры INSTEAD OF не поддерживают прямую рекурсию.
        Контрлируется на уровне базы данных через параметр RECURSIVE_TRIGGERS и по умолчанию отключена. Отключение прямой рекурсии триггеров INSTEAD OF требует, чтобы вы также была установлена опция nested triggers в 0.
        Более сложная форма прямой рекурсии может возникать, когда повторно вызывается тот же триггер, но лишь после того, как вызван триггер другого типа (AFTER или INSTEAD OF).
    
    Косвенная.
        Возникает, когда триггер запускает другой триггер (который может запускать другой триггер и т.д.), который в конце концов запускает первый триггер.
        Контролируется на уровне сервера через параметр конфигурации nested_triggers (триггеры INSTEAD OF могут быть вложенными вне зависимости от этого параметра).
	
    Общее количество рекурсивных вызовов, которые могут быть сделаны, ограничено 32.
	
    Функция TRIGGER_NESTLEVEL() использутся для определения текущего уровня вложенности.

Чтобы узнать были ли изменены строки, сначала надо проверить переменную @ROWCOUNT, потом таблицы inserted или/и deleted.
    
Функции UPDATE И COLUMNS_UPDATED.
    Функция UPDATE принимает имя столбца в качестве входных данных и возвращает TRUE, если столбец ввода был указан в предложении SET инструкции запуска UPDATE (в инструкции INSERT возвращает TRUE для любого столбца).
    
    Функция COLUMNS_UPDATED возвращает двоичную строку с битом для каждого столбца (как извлечь байт соответсвующий колонке или сгенерировать маску см. Inside Microsoft SQL Server 2008: T-SQL Programming - 4. Triggers - UPDATE AND COLUMNS_UPDATED).
    Позиция COLUMNS_UPDATED не совпадает с значением ORDINAL_POSITION, найденным в представлении каталога INFORMATION_SCHEMA.COLUMNS, используйте sys.columns.ColumnID значение.
 
Процедура sp_settriggerorder позволяет пометить триггер, который будет запускаться первым, и тот, который будет срабатывать последним. Порядок запуска триггеров между первым и последним не определен.
	
Оператор ROLLBACK TRANSACTION в триггере откатывает транзакцию и предотвращает запуск других триггеров с помощью текущего триггера. 
Клиент получает два сообщения об ошибках: тот, который был вызван RAISERROR () , и ошибка 3609 или 3616, предупреждая о том, что транзакция закончилась триггером.
    
Обмен данными с триггерами:
    - переменная сессии CONTEXT_INFO;
    - хранилище типа key-value SESSION_CONTEXT.
    
Находясь в теле триггера, вы всегда находитесь в транзакции, даже если вы никогда не выдавали BEGIN TRANSACTION, поскольку триггер логически является частью инструкции, которая запускает триггер.
В SQL 2005 и SQL 2008 XACT_STATE() вернет 0, если транзакция является системной. XACT_STATE() сообщает значение, если есть явная транзакция пользователя. Это было исправлено в SQL 2012.
По умолчанию в триггерах XACT_ABORT установлен в ON. Это также относится ко всем хранимым процедурам, вызываемым из триггера.
Если вы откатываете или завершаете (чего никогда не надо делать) транзакцию в триггере, SQL Server вызывает ошибку 3609.
Ошибка 266, никогда не возникает при вызове хранимой процедуры из триггера.

Необходимо убедиться, что триггеры должным образом обрабатывают многострочные модификации, модификации столбцов первичного ключа и изоляцию моментальных снимков.

Типичные проблемы с целостностью данных, связанные с триггерами:
    - некоторые триггеры ложно предполагают, что только одна строка за раз вставлена​​/обновлена​​/удалена;
    - некоторые триггеры ошибочно предполагают, что столбцы первичного ключа никогда не будут изменены;
    - при некоторых обстоятельствах триггеры не срабатывают;
        - отключение триггера;
        - использование IGNORE_TRIGGERS подсказки в INSERT заявлении, когда BULK опция используется с OPENROWSET;
        - когда nested triggers или recursive_triggers установка предотвращает срабатывание триггера;
        - TRUNCATE TABLE команда не может активировать триггер FOR DELETE или INSTEAD OF DELETE;
        - когда BULK INSERT запускается без опции FIRE_TRIGGERS;
        - если триггер отбрасывается и позже воссоздается, любые изменения, внесенные в таблицу в промежуточный период, не будут подвержены логике триггера;
        - если таблица отбрасывается и воссоздается;
        - когда родительские и дочерние таблицы находятся в разных базах данных и восстанавливается старая резервная копия родительской базы данных.
    - триггеры могут отменять изменения, внесенные другими триггерами;
    - некоторые триггеры не работают под уровнями выделения моментальных снимков.
    
В SQL Server 2014 и 2016 не позволяет определить триггеры в таблице с индексами columnstore.