Временные таблицы.
    Виды временных таблиц:
        - Локальные временные таблицы. Начинаются с символа #, и они видны только в сеансе, в котором они были созданы, и в модулях, вызываемых с этого сеанса.
        - Глобальные временные таблицы. Начинаются с символов ##, и они видны для всех сеансов.

    Локальная временная таблица, созданная в хранимой процедуре, доступна в этой конкретной хранимой процедуре, а также в хранимых процедурах, которые вызываются из этой хранимой процедуры и в динамическом SQL.

    В триггерах, можно получить доступ к временной таблице, созданной в хранимой процедуре, если хранимая процедура выполняет действие, которое запускает эти триггеры.

    Временную таблицы можно удалить с помощью инструкции DROP TABLE. Что бы проверить существование временной таблицы с помощью OBJECT_ID, убедитесь, что указали префикс базы данных tempdb (OBJECT_ID('tempdb..#T1', 'U')).

    Локальные временные таблицы будут удалены, когда завершиться сеанс или выполнение модуля, в котором они были созданы.
    Глобальные временные таблицы будут удалены, когда завершаться все сеансы ссылающиеся на них.

    На временных таблицах можно создавать кластерные и некластеризованные индексы и определять ограничения.
    
    SQL Server поддерживает статистику индексов, определенных во временных таблицах, подобно обычным таблицам. 
    Cтатистика может автоматически создаваться на временных таблицах (без потери преимуществ временного кэширования объектов).
    
    Временные таблицы имеют дополнительный порог обновления статистики: 
        кол-во строк < 6, порог перекомпиляции = 6 
        6 ≤ кол-во строк ≤ 500, порог перекомпиляции = 500
        кол-во строк > 500, порог перекомпиляции = 500 + 0,20 × n
        
    Подсказка KEEP PLAN позволяет предотвратить обновление статистики на основе этого порога и соответствует поведению обычной таблицы:
        кол-во строк ≤ 500, порог перекомпиляции = 500
        кол-во строк > 500, порог перекомпиляции = 500 + 0,20 × n
    
    Статистика, связанная с кэшированной временной таблицей, не сбрасывается, когда объект кэшируется в конце модуля или когда кешированный объект извлекается из кеша в начале модуля.
    Как следствие, статистика может не иметь абсолютно никакого отношения к текущему содержимому временной таблицы.
    
    Наиболее полное обходное решение, сохраняя при этом преимущества временного кэширования объектов, заключается в следующем:
        - UPDATE STATISTICS на временной таблице в модуле.
        - Добавлеине OPTION (RECOMPILE) подсказку к операторам, которые ссылаются на временную таблицу.
    
    Временные таблицы создаются и живут в TempDB.
    
    Если таблица имеет размер 8 Мбайт или меньше, усечение выполняется синхронно, в противном случае используется отсроченное падение.
    Явное TRUNCATE TABLE позволяет вызвать процесс усечения с более коротким таймером.
    Если вы отключите отложенное падение (deferred drop) глобально с помощью недокументированного флага трассировки 671, усечение будет выполняется синхронно.
        
    Создание и удаление временных таблиц требует доступа и модификации карты распределения страниц, таких как IAM, SGAM и PFS, а также системных таблиц.
    
    Чтобы повысить производительность, SQL Server представляет концепцию кэширования временных объектов. Вместо того, чтобы отбрасывать временную таблицу, SQL Server усекает ее, сохраняя две страницы на предварительно выделенный индекс: одну IAM и одну страницу данных.
    В следующий раз, когда временная таблица будет создана, SQL Server будет повторно использовать эти страницы, что поможет уменьшить количество изменений, необходимых на страницах карт распределения.
    Для процедур, которые вызывают очень часто, это может сэкономить время и уменьшить количество конфликтов на таблицах системного каталога и на страницах распределения.
    
    SQL Server не кэширует IAM или страницы данных для глобальных временных таблиц и не кэширует локальные временные таблицы, созданные в области сеанса.
    Кэшируются только временные таблицы, созданные в хранимых процедурах, триггерах, multi-statement table-valued function и scalar user-defined function.
    Возвращаемое значение multi-statement table-valued function представляет собой переменную таблицы, которая сама может быть кэширована.
    
    Если хранимая процедура выполняется одновременно, в tempdb может быть создано несколько отдельных кешированных объектов. 
    Для этой процедуры есть один кэшированный план, но один временный объект кэшированием на каждый контекст выполнения, полученный из этого кэшированного плана.
    Также может быть более одного кэшированного плана для процедуры в кеше (например, из-за компиляций с разными параметрами SET), и каждый план будет иметь свою собственную коллекцию контекстов выполнения, 
    поэтому может быть один кешированный объект tempdb для каждого контекста выполнения на каждый план.
    
    Требования к таблице и коду, что бы поддерживалась концепция кэширования:
        - Таблица должена быть меньше восьми мегабайт. Большие таблицы не кэшируются.
        - Нет операторов DDL, которые изменяют структуру таблицы. Любые инструкции модификации схемы в коде, за исключением DROP, предотвращают кэширование временных объектов.       
        - В таблице не указаны именованные ограничения (в любом случае, плохая идея, поскольку одновременное выполнение может вызвать столкновение имен). Безымянные ограничения не будут препятствовать кешированию.
        - Таблица не создается с помощью динамического SQL.
        - Автоматическое создание статистики и инструкция UPDATE STATISTICS не предотвращает кеширование.
          Инструкция CREATE STATISTICS предотвращает кэширование.
            
    Кэшированный объект привязан к плану запроса, который ссылается на него. 
    Если план выведен из кеша по любой причине (ALTER/DROP PROCEDURE, опция WITH RECOMPILE или явной команды DBCC FREEPROCCACHE) фоновый поток удаляет объект из tempdb. Это не является синхронным с командой вызывающей выселение, присутствует задержка.
    SQL Server также удаляет кэшированные временные объекты, когда TempDB имеет мало свободного места.
    
    Все временные объекты в модуле оцениваются отдельно для кэширования. Модуль, содержащий один или несколько временных объектов, которые нельзя кэшировать, может по-прежнему квалифицироваться для кэширования других временных объектов в одном модуле.
    
    Временные таблицы полностью осведомлены о транзакциях, аналогично обычным таблицам.
    
    Временное кэширование объектов может быть недостаточным, чтобы уменьшить конфликты tempdb до приемлемых уровней во всех случаях.
    Использование табличных переменных оптимизированных для памяти или недолговечных таблиц оптимизированных для памяти может обеспечить целевые решения в таких случаях.
    
Табличные переменные.
    
    Табличные переменные так же, как и временные таблицы создаются и живут в TempDB. In-Memory OLTP технология, позволяет создавать оптимизированные в памяти табличные переменные (живут только в памяти и не используют TempDB).
    
    Табличные переменные кэшируются так же, как временные таблицы.
    
    Ограничения:
        - Нельзя создавать индексы, за исключением PRIMARY KEY и UNIQUE ограничений.
        - Нельзя изменить определение переменной таблицы после ее объявления.
        - Нельзя использовать SELECT INTO, вместо этого вы должны использовать INSERT SELECT.
          SQL Server 2008 добавляет оператор INSERT SELECT в список методов вставки, которые могут выполняться в режиме минимального журнала, точно так же, как SELECT INTO.
          Это улучшение в SQL Server 2008 означает, что временные таблицы не имеют преимуществ по сравнению с табличными переменными с точки зрения ведения журнала.
        - В запросах, которые изменяют переменную таблицы, параллельные планы не будут использоваться. Запросы, которые считываются только из табличных переменных, могут быть распараллелены.
    
    SQL Server не поддерживает статистику табличных переменных и всегда оценивает, что табличная переменная имеет только одну строку (необходимо быть очень осторожным, особенно когда хранятся большие объемы данных в табличной переменной), если не используется перекомпиляция (RECOMPILE) на уровне инструкций.
    Когда флаг трассировки 2453 активен, оптимизатор может получить точный рисунок мощности после создания табличной перемнной (см. https://sqlperformance.com/2014/06/t-sql-queries/table-variable-perf-fix).
    
    Табличные переменные лучше всего использовать, когда данные малы (идеально подходят для одной страницы данных для максимальной конкурентной выгоды), и когда выбор плана не зависит от значений, присутствующих в переменной таблицы.

    Безопаснее использовать временные таблицы, чем табличные переменные, когда необходимо соединиться с другими таблицами.
    С оценкой мощности в одну строку Query Optimizer обычно выбирает вложенный цикл, когда табличная переменная присутствует в соединении (этот тип соединения очень неэффективен в тех случаях, когда имеется большой объем данных, хранящихся в обоих входах объединения).

    В отличие от временной таблицы переменная таблицы не является частью внешней транзакции. Если при изменении табличной переменной, оператор модификации будет прерван (например: нарушение ключа), изменения этого конкретного оператора будут отменены.
    Однако, если оператор является частью внешней транзакции, которая откатывается назад, изменения табличной переменной не будут отменены.
    
    Табличные переменные с столбцами типа XML не могут иметь индекс XML.